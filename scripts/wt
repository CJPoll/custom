#!/bin/bash

set -euo pipefail

PROJECT_DIR="$(pwd)"
WORKTREES_DIR="${HOME}/.local/worktrees/$(basename $PROJECT_DIR)"

QUIET=false
NO_SYMLINK=false
CHECK_DIR=""
PR_REVIEW=false
PARENT_BRANCH="main"
SWITCH_AFTER_CREATE=false

usage() {
    cat << EOF
Usage: wt <command> [options]

Commands:
  init              Set up the worktrees directory
  list              List all worktrees for the current project
  create <branch>   Create a worktree for the specified branch
                    (symlinks .claude/ directory from main project if present)
  rm <branch>       Remove the worktree for the specified branch
  switch <branch>   Change to the worktree for the specified branch
  merge <branch>    Merge a worktree branch (must be run from parent repo)
  is-worktree       Check if a directory is a git worktree
                    Exit codes: 0=worktree, 1=project root, 2=neither
  stack             Show branch hierarchy for all worktrees in the project
  sync [branch]     Sync the stack using git-stack for the current or specified branch

Options:
  --quiet           Suppress output from script and subcommands
  --no-symlink      Do not create symlink to .claude directory (for create command)
  --switch          Switch to the worktree after creating it (for create command)
  --dir <directory> Check the specified directory (for is-worktree command, defaults to current dir)
  --pr-review       Open changed files in tabs for PR review (for switch command)
  --parent <branch> Parent branch for PR review or stack creation (defaults to main)

Examples:
  wt init
  wt list
  wt create feature/my-feature
  wt create feature/child --parent feature/parent
  wt create --no-symlink experimental/test
  wt create --switch feature/my-feature
  wt switch feature/my-feature
  wt switch feature/my-feature --pr-review
  wt switch feature/my-feature --pr-review --parent develop
  wt rm feature/my-feature
  wt merge feature/my-feature
  wt create --quiet bugfix/issue-123
  wt is-worktree
  wt is-worktree --dir /path/to/directory
  wt stack
  wt sync
  wt sync feature/child
EOF
}

log() {
    if [ "$QUIET" = false ]; then
        echo "$@" >&2
    fi
}

run_cmd() {
    if [ "$QUIET" = true ]; then
        "$@" >/dev/null 2>&1
    else
        "$@"
    fi
}

init_worktrees() {
    log "Initializing worktrees directory..."
    
    if [ ! -d "$PROJECT_DIR/.git" ]; then
        echo "Error: Not in a git repository" >&2
        exit 1
    fi
    
    mkdir -p "$WORKTREES_DIR"
    
    log "Worktrees directory initialized at: $WORKTREES_DIR"
}

list_worktrees() {
    if [ ! -d "$WORKTREES_DIR" ]; then
        log "No worktrees directory found. Run 'wt init' first."
        return 0
    fi
    
    # Get list of directories in worktrees
    local worktrees=()
    if [ -d "$WORKTREES_DIR" ]; then
        while IFS= read -r -d '' dir; do
            worktrees+=("$(basename "$dir")")
        done < <(find "$WORKTREES_DIR" -mindepth 1 -maxdepth 1 -type d -print0 2>/dev/null)
    fi
    
    if [ ${#worktrees[@]} -eq 0 ]; then
        log "No worktrees found."
        return 0
    fi
    
    # Get current branch for comparison
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
    
    log "Worktrees for this project:"
    log ""
    
    # Use git worktree list to get more info
    local git_worktrees
    git_worktrees=$(git worktree list 2>/dev/null || echo "")
    
    for worktree in "${worktrees[@]}"; do
        local marker=""
        local worktree_path="$WORKTREES_DIR/$worktree"
        
        # Check if this is the current directory
        if [[ "$(pwd)" == "$worktree_path" ]]; then
            marker=" *"
        fi
        
        # Try to get the commit info from git worktree list
        local commit_info=""
        if [[ -n "$git_worktrees" ]]; then
            commit_info=$(echo "$git_worktrees" | grep "$worktree_path" | awk '{print $2, $3}' || echo "")
        fi
        
        if [[ -n "$commit_info" ]]; then
            echo "  $worktree$marker ($commit_info)"
        else
            echo "  $worktree$marker"
        fi
    done
}

create_worktree() {
    local branch="$1"
    local worktree_path="$WORKTREES_DIR/$branch"
    
    if [ -z "$branch" ]; then
        echo "Error: Branch name is required" >&2
        usage
        exit 1
    fi
    
    if [ ! -d "$WORKTREES_DIR" ]; then
        log "Worktrees directory not found. Running init first..."
        init_worktrees
    fi
    
    if [ -d "$worktree_path" ]; then
        echo "Error: Worktree already exists at: $worktree_path" >&2
        exit 1
    fi
    
    log "Creating worktree for branch: $branch"
    
    # Determine the base branch for the new worktree
    local base_branch="$PARENT_BRANCH"
    
    # Check if branch exists
    if git show-ref --verify --quiet "refs/heads/$branch"; then
        log "Checking out existing branch: $branch"
        run_cmd git worktree add "$worktree_path" "$branch"
    else
        # Check if it exists as a remote branch
        if git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
            log "Creating local branch from remote: origin/$branch"
            run_cmd git worktree add "$worktree_path" -b "$branch" "origin/$branch"
        else
            # Create new branch from the parent branch
            if [ "$base_branch" != "main" ] && [ "$base_branch" != "master" ]; then
                log "Creating new branch: $branch from parent: $base_branch"
                # Ensure parent branch exists
                if git show-ref --verify --quiet "refs/heads/$base_branch"; then
                    run_cmd git worktree add "$worktree_path" -b "$branch" "$base_branch"
                else
                    echo "Error: Parent branch '$base_branch' does not exist" >&2
                    exit 1
                fi
            else
                log "Creating new branch: $branch"
                run_cmd git worktree add "$worktree_path" -b "$branch"
            fi
        fi
    fi
    
    log "Worktree created at: $worktree_path"
    
    # Configure git-stack parent relationship if parent was specified
    if [ "$PARENT_BRANCH" != "main" ] && [ "$PARENT_BRANCH" != "master" ]; then
        log "Configuring git-stack parent relationship: $branch -> $PARENT_BRANCH"
        git -C "$worktree_path" config --add git-stack.auto-base "$PARENT_BRANCH"
        git -C "$worktree_path" config --add "branch.$branch.stack-base" "$PARENT_BRANCH"
    fi
    
    # Create symlink to .claude directory if it exists in the main project (unless --no-symlink is set)
    if [ "$NO_SYMLINK" = false ] && [ -d "$PROJECT_DIR/.claude" ]; then
        if [ ! -e "$worktree_path/.claude" ]; then
            ln -s "$PROJECT_DIR/.claude" "$worktree_path/.claude"
            log "Created symlink to .claude directory"
        else
            log "Warning: .claude already exists in worktree, skipping symlink"
        fi
    fi
}

remove_worktree() {
    local branch="$1"
    local worktree_path="$WORKTREES_DIR/$branch"
    
    if [ -z "$branch" ]; then
        echo "Error: Branch name is required" >&2
        usage
        exit 1
    fi
    
    if [ ! -d "$worktree_path" ]; then
        echo "Error: Worktree not found at: $worktree_path" >&2
        exit 1
    fi
    
    log "Removing worktree for branch: $branch"
    
    # Get the project name from the current directory
    local project_name=$(basename "$PROJECT_DIR")
    
    # Create session name with worktree info (same format as in switch_worktree)
    # Replace slashes in branch name with dashes to avoid tmux issues
    local safe_branch=$(echo "$branch" | tr '/' '-')
    local session_name="${project_name}-wt-${safe_branch}"
    
    # Check if tmux session exists and kill it
    if tmux has-session -t "$session_name" 2>/dev/null; then
        log "Killing tmux session: $session_name"
        run_cmd tmux kill-session -t "$session_name"
    fi
    
    # Remove the worktree
    run_cmd git worktree remove "$worktree_path" --force
    
    # Clean up any remaining directory if it exists
    if [ -d "$worktree_path" ]; then
        rm -rf "$worktree_path"
    fi
    
    # Prune worktree metadata
    run_cmd git worktree prune
    
    log "Worktree removed: $branch"
}

switch_worktree() {
    local branch="$1"
    local worktree_path="$WORKTREES_DIR/$branch"
    
    if [ -z "$branch" ]; then
        echo "Error: Branch name is required" >&2
        usage
        return 1
    fi
    
    if [ ! -d "$worktree_path" ]; then
        echo "Error: Worktree not found at: $worktree_path" >&2
        echo "Available worktrees:" >&2
        if [ -d "$WORKTREES_DIR" ]; then
            ls -1 "$WORKTREES_DIR" 2>/dev/null | sed 's/^/  /' >&2
        fi
        return 1
    fi
    
    log "Switching to worktree: $branch"
    
    # Get the project name from the current directory
    local project_name=$(basename "$PROJECT_DIR")
    
    # Create session name with worktree info
    # Replace slashes in branch name with dashes to avoid tmux issues
    local safe_branch=$(echo "$branch" | tr '/' '-')
    local session_name="${project_name}-wt-${safe_branch}"
    
    # Call proj directly, with optional --pr-review flag
    if [ "$PR_REVIEW" = true ]; then
        proj "$session_name" --path "$worktree_path" --pr-review --base-branch "$PARENT_BRANCH"
    else
        proj "$session_name" --path "$worktree_path"
    fi
}

merge_worktree() {
    local branch="$1"
    local worktree_path="$WORKTREES_DIR/$branch"
    
    if [ -z "$branch" ]; then
        echo "Error: Branch name is required" >&2
        usage
        return 1
    fi
    
    # Check if we're in the parent worktree (not a worktree)
    # Run is_worktree in a subshell to capture exit code
    local is_wt_result
    # Run in a subshell to prevent exit from terminating our script
    # Temporarily disable set -e for this check
    set +e
    (
        CHECK_DIR="$(pwd)"
        is_worktree
    )
    is_wt_result=$?
    set -e
    
    if [ $is_wt_result -eq 0 ]; then
        echo "Error: wt merge must be run from the parent repository, not a worktree" >&2
        return 1
    elif [ $is_wt_result -eq 2 ]; then
        echo "Error: Not in a git repository" >&2
        return 1
    fi
    # is_wt_result == 1 means we're in the project root, which is what we want
    
    # Check if worktree exists
    if [ ! -d "$worktree_path" ]; then
        echo "Error: No worktree found for branch: $branch" >&2
        echo "Available worktrees:" >&2
        if [ -d "$WORKTREES_DIR" ]; then
            ls -1 "$WORKTREES_DIR" 2>/dev/null | sed 's/^/  /' >&2
        fi
        return 2
    fi
    
    log "Merging branch: $branch"
    
    # Get the merge base
    local merge_base=$(git merge-base HEAD "$branch" 2>/dev/null)
    if [ -z "$merge_base" ]; then
        echo "Error: Could not find merge base for branch: $branch" >&2
        return 1
    fi
    
    # Check if fast-forward is possible
    if ! git merge-base --is-ancestor HEAD "$branch" 2>/dev/null; then
        echo "Error: Cannot fast-forward merge. The branch has diverged." >&2
        return 1
    fi
    
    # Get the diff for the merge
    local diff_output=$(git diff "$merge_base".."$branch" 2>/dev/null)
    
    if [ -z "$diff_output" ]; then
        echo "No changes to merge from branch: $branch"
        return 0
    fi
    
    # Generate commit message using Claude
    log "Generating merge commit message..."
    local commit_message=$(echo "$diff_output" | claude -p "Generate a concise merge commit message based on this diff. The message should summarize what changes are being merged. Format: 'Merge <other-branch> -> <current-branch>: <summary of changes>'. Keep it under 72 characters for the first line, and add details below if needed. Give no additional output beyond the commit message. Format according to 'conventional commits' style, providing all information in teh 'conventional commit' specification which is currently avaialable. Include credit to Claude Code as co-author. Do not surround the commit message with quotes, backticks, or other symbols." 2>/dev/null)
    
    if [ -z "$commit_message" ]; then
        # Fallback message if Claude fails
        commit_message="Merge $branch"
    fi
    
    # Perform the merge with squash
    log "Performing merge..."
    if git merge --ff-only --squash "$branch" 2>&1; then
        # Commit with the generated message
        if git commit -m "$commit_message" 2>&1; then
            log "Merge completed successfully"
            
            # Remove the worktree
            log "Removing merged worktree..."
            remove_worktree "$branch"
        else
            echo "Error: Failed to commit merge" >&2
            # Reset the merge
            git merge --abort 2>/dev/null || git reset --hard HEAD 2>/dev/null
            return 1
        fi
    else
        echo "Error: Merge failed" >&2
        return 1
    fi
}

is_worktree() {
    local dir="${CHECK_DIR:-$(pwd)}"
    
    # Get the absolute path
    dir="$(realpath "$dir" 2>/dev/null)" || exit 2
    
    # Check if directory is an immediate child of any DEVPATH directory
    if [[ -n "$DEVPATH" ]]; then
        # Split DEVPATH by colon
        IFS=':' read -ra DEV_DIRS <<< "$DEVPATH"
        for dev_dir in "${DEV_DIRS[@]}"; do
            # Expand the dev_dir path (handle ~ and variables)
            dev_dir="$(eval echo "$dev_dir")"
            dev_dir="$(realpath "$dev_dir" 2>/dev/null)" || continue
            
            # Check if dir is an immediate child of this dev_dir
            local parent_dir="$(dirname "$dir")"
            if [[ "$parent_dir" == "$dev_dir" ]]; then
                # This is a project root directory, not a worktree
                exit 1
            fi
        done
    fi
    
    # Find the git directory by traversing up from the target directory
    local git_dir="$dir"
    while [[ "$git_dir" != "/" ]]; do
        if [[ -d "$git_dir/.git" ]] || [[ -f "$git_dir/.git" ]]; then
            # Check if git worktree list contains this directory
            if git -C "$git_dir" worktree list 2>/dev/null | grep -q "^$dir\s"; then
                exit 0
            else
                exit 2
            fi
        fi
        git_dir="$(dirname "$git_dir")"
    done
    
    # Not in a git repository
    exit 2
}

show_worktree_stack() {
    # Check if git-stack is available
    if ! command -v git-stack &>/dev/null; then
        echo "Error: git-stack not found. Install from https://github.com/gitext-rs/git-stack" >&2
        return 1
    fi
    
    # Check if we're in a git repository
    if ! git rev-parse --git-dir &>/dev/null; then
        echo "Error: Not in a git repository" >&2
        return 1
    fi
    
    # Build branch->worktree mapping
    declare -A branch_to_worktree
    declare -A worktree_to_current
    
    # Get current directory for comparison
    local current_dir="$(pwd)"
    
    # Add main project directory
    local main_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    if [ -n "$main_branch" ]; then
        branch_to_worktree["$main_branch"]="$PROJECT_DIR"
        if [[ "$current_dir" == "$PROJECT_DIR" ]]; then
            worktree_to_current["$PROJECT_DIR"]="*"
        fi
    fi
    
    # Add worktrees
    if [ -d "$WORKTREES_DIR" ]; then
        for wt in "$WORKTREES_DIR"/*; do
            [ -d "$wt" ] || continue
            local branch=$(git -C "$wt" rev-parse --abbrev-ref HEAD 2>/dev/null)
            if [ -n "$branch" ]; then
                branch_to_worktree["$branch"]="$wt"
                if [[ "$current_dir" == "$wt" ]]; then
                    worktree_to_current["$wt"]="*"
                fi
            fi
        done
    fi
    
    log "Branch hierarchy for project: $(basename "$PROJECT_DIR")"
    log ""
    
    # Process git-stack output line by line
    local first_worktree_seen=false
    local start_extra_indent=false
    local in_indented_section=false
    
    git stack 2>&1 | while IFS= read -r line; do
        # Skip empty lines
        if [[ -z "$line" ]]; then
            echo "$line"
            continue
        fi
        
        # Check if we're starting/ending an indented section
        if [[ "$line" =~ ^[[:space:]]*│ ]]; then
            in_indented_section=true
        else
            # Reset when we leave an indented section
            in_indented_section=false
            first_worktree_seen=false
            start_extra_indent=false
        fi
        
        # Look for worktree branches in indented sections
        local found_worktree_on_this_line=false
        if [[ "$in_indented_section" == true ]]; then
            for branch in "${!branch_to_worktree[@]}"; do
                if [[ "$line" =~ (^|[[:space:],│├└─⌽])${branch}([[:space:],\(]|$) ]]; then
                    found_worktree_on_this_line=true
                    if [[ "$first_worktree_seen" == false ]]; then
                        # This is the first worktree in the section
                        first_worktree_seen=true
                        # Don't indent THIS line, but indent everything after
                    else
                        # This is a second worktree - should already be indenting
                        true
                    fi
                    break
                fi
            done
            
            # Start indenting from the line AFTER the first worktree
            # Only if we've seen a worktree AND this line doesn't have the first worktree
            if [[ "$first_worktree_seen" == true ]] && [[ "$found_worktree_on_this_line" == false ]]; then
                start_extra_indent=true
            fi
        fi
        
        # Apply extra indentation if needed
        local output_line="$line"
        if [[ "$start_extra_indent" == true ]] && [[ "$in_indented_section" == true ]] && [[ "$line" =~ ^([[:space:]]*│[[:space:]]*) ]]; then
            local prefix="${BASH_REMATCH[1]}"
            local rest="${line#$prefix}"
            # Add extra "│ " for indentation
            prefix="${prefix}│ "
            output_line="${prefix}${rest}"
        fi
        
        # Add annotations to branch names
        local modified_line="$output_line"
        
        # Process branches in order of length (longest first)
        local sorted_branches=()
        while IFS= read -r branch; do
            sorted_branches+=("$branch")
        done < <(printf '%s\n' "${!branch_to_worktree[@]}" | awk '{ print length, $0 }' | sort -nr | cut -d' ' -f2-)
        
        for branch in "${sorted_branches[@]}"; do
            local wt_path="${branch_to_worktree[$branch]}"
            local annotation=""
            local marker=""
            
            if [ ${worktree_to_current[$wt_path]+isset} ]; then
                marker="*"
            fi
            
            if [[ "$wt_path" == "$PROJECT_DIR" ]]; then
                if [ -n "$marker" ]; then
                    annotation="[main*]"
                else
                    annotation="[main]"
                fi
            else
                if [ -n "$marker" ]; then
                    annotation="[wt*]"
                else
                    annotation="[wt]"
                fi
            fi
            
            # Check if branch appears in the line with proper boundaries
            if [[ "$modified_line" =~ (^|[[:space:],│├└─⌽])${branch}([[:space:],\(]|$) ]]; then
                modified_line="${modified_line//${branch}/${branch}${annotation}}"
            fi
        done
        
        echo "$modified_line"
    done
}

sync_worktree_stack() {
    local branch="${1:-}"
    
    # Check if git-stack is available
    if ! command -v git-stack &>/dev/null; then
        echo "Error: git-stack not found. Install from https://github.com/gitext-rs/git-stack" >&2
        return 1
    fi
    
    # If branch is provided, switch to that worktree first
    if [ -n "$branch" ]; then
        local worktree_path="$WORKTREES_DIR/$branch"
        
        if [ ! -d "$worktree_path" ]; then
            echo "Error: Worktree not found for branch: $branch" >&2
            echo "Available worktrees:" >&2
            if [ -d "$WORKTREES_DIR" ]; then
                ls -1 "$WORKTREES_DIR" 2>/dev/null | sed 's/^/  /' >&2
            fi
            return 1
        fi
        
        log "Syncing stack for branch: $branch"
        
        # Run git-stack sync in the worktree
        cd "$worktree_path"
        git stack sync
        local result=$?
        
        # Return to original directory
        cd - >/dev/null
        
        return $result
    else
        # No branch specified, sync in current directory
        # First check if we're in a git repository
        if ! git rev-parse --git-dir &>/dev/null; then
            echo "Error: Not in a git repository" >&2
            return 1
        fi
        
        local current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        log "Syncing stack for current branch: $current_branch"
        
        # Run git-stack sync
        git stack sync
    fi
}

# Parse command line arguments
COMMAND=""
BRANCH=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --quiet)
            QUIET=true
            shift
            ;;
        --no-symlink)
            NO_SYMLINK=true
            shift
            ;;
        --switch)
            SWITCH_AFTER_CREATE=true
            shift
            ;;
        --pr-review)
            PR_REVIEW=true
            shift
            ;;
        --parent)
            shift
            if [[ $# -eq 0 ]]; then
                echo "Error: --parent requires a branch name" >&2
                exit 1
            fi
            PARENT_BRANCH="$1"
            shift
            ;;
        --dir)
            shift
            if [[ $# -eq 0 ]]; then
                echo "Error: --dir requires a directory path" >&2
                exit 1
            fi
            CHECK_DIR="$1"
            shift
            ;;
        init|list|ls|create|rm|switch|merge|is-worktree|stack|sync)
            COMMAND="$1"
            shift
            ;;
        -h|--help|help)
            usage
            exit 0
            ;;
        *)
            # If we have a command that expects a branch and no branch is set yet,
            # treat this as the branch name
            if [[ -n "$COMMAND" ]] && [[ -z "$BRANCH" ]] && [[ "$COMMAND" =~ ^(create|rm|switch|merge|sync)$ ]]; then
                BRANCH="$1"
                shift
            else
                echo "Error: Unknown argument: $1" >&2
                usage
                exit 1
            fi
            ;;
    esac
done

# Execute the appropriate command
case "$COMMAND" in
    init)
        init_worktrees
        ;;
    list|ls)
        list_worktrees
        ;;
    create)
        create_worktree "$BRANCH"
        if [ "$SWITCH_AFTER_CREATE" = true ]; then
            switch_worktree "$BRANCH"
        fi
        ;;
    rm)
        remove_worktree "$BRANCH"
        ;;
    switch)
        switch_worktree "$BRANCH"
        ;;
    merge)
        merge_worktree "$BRANCH"
        ;;
    is-worktree)
        is_worktree
        ;;
    stack)
        show_worktree_stack
        ;;
    sync)
        sync_worktree_stack "$BRANCH"
        ;;
    "")
        echo "Error: No command specified" >&2
        usage
        exit 1
        ;;
    *)
        echo "Error: Unknown command: $COMMAND" >&2
        usage
        exit 1
        ;;
esac

