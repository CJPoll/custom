#!/bin/bash

set -euo pipefail

# Source the install_git_stack script
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [ -f "${SCRIPT_DIR}/../install_git_stack.sh" ]; then
    source "${SCRIPT_DIR}/../install_git_stack.sh"
fi

# Determine if we're in a worktree and find the actual project root
CURRENT_DIR="$(pwd)"
PROJECT_DIR="$CURRENT_DIR"

# Check if we're in a worktree by looking for .git file (not directory)
if [ -f "$CURRENT_DIR/.git" ]; then
    # We're in a worktree, extract the actual project path
    GIT_DIR=$(cat "$CURRENT_DIR/.git" | grep "gitdir:" | cut -d' ' -f2)
    # Git dir for worktree looks like: /path/to/project/.git/worktrees/branch-name
    # We need to go up 3 levels to get the project root
    PROJECT_DIR=$(dirname $(dirname $(dirname "$GIT_DIR")))
fi

# Extract just the project name from the path
PROJECT_NAME=$(basename "$PROJECT_DIR")
WORKTREES_DIR="${HOME}/.local/worktrees/$PROJECT_NAME"

QUIET=false
NO_SYMLINK=false
CHECK_DIR=""
PR_REVIEW=false
# Default parent branch to current branch instead of main
PARENT_BRANCH="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'main')"
PARENT_BRANCH_EXPLICIT=false
SWITCH_AFTER_CREATE=false

usage() {
    cat << EOF
Usage: wt <command> [options]

Commands:
  init              Set up the worktrees directory
  list              List all worktrees for the current project
  ls                List all worktrees (alias for list)
  create <branch>   Create a worktree for the specified branch
                    (symlinks .claude/ directory from main project if present)
  rm <branch>       Remove the worktree for the specified branch
  close <branch>    Remove worktree and delete the local branch
                    (Cannot be used on main/master branches)
  close --all       Remove all worktrees and delete their branches
                    (Must be run from main branch worktree, skips main/master)
  reset             Remove all worktrees and delete their branches
                    (Skips main/master branches)
  switch <branch>   Change to the worktree for the specified branch
                    (In tmux: switches/creates session. Outside tmux: shows cd command)
  merge <branch>    Merge a worktree branch (must be run from parent repo)
  worktree-dir <branch>  Get the directory path for a branch's worktree
                    Exit codes: 0=found (prints path), 1=not found (no output)
  is-worktree       Check if a directory is a git worktree
                    Exit codes: 0=worktree, 1=project root, 2=neither
  stack             Show all tracked branches and their relationships (gt ls)
  stack --current   Show only the current branch's stack (gt ls -s)
  stack --install   Install Graphite (gt) if not already installed
                    Downloads and installs Graphite from https://graphite.dev
  stack parent [branch] Show or set the parent branch for the current branch
  stack open <branch>    Create worktrees for all branches in the stack up to the given branch
                    Must be run from main branch worktree
  stack open --create-sessions  Also create tmux sessions for each worktree (without switching)
  stack move        Change a branch's parent or reorder siblings
                    --onto <parent>: move to new parent (delegates to gt)
                    --up/--down: reorder among siblings
                    --dry-run: preview changes without applying
  stack reorder     Rearrange multiple branches in the stack interactively (delegates to gt)
  sync              Sync the stack with remote changes using Graphite (gt sync)
  sync --continue   Continue a sync operation after resolving conflicts (gt continue)
  restack           Fix stack relationships and rebase onto correct parents (gt restack)
  next              Navigate to a child branch in the stack (switch tmux session)
  prev              Navigate to the parent branch in the stack (switch tmux session)
  run <command>     Execute a command across all branches in the stack (in dependency order)
  push --stack      Push all branches in the stack using Graphite (gt submit)
  pr --stack        Create/update pull requests for the stack using Graphite
  migrate-to-gt     Migrate existing git-stack metadata to Graphite format
                    One-time migration for projects using git-stack
  modify [options]  Amend current commit with auto-restacking (delegates to gt)

Options:
  --quiet           Suppress output from script and subcommands
  --no-symlink      Do not create symlink to .claude directory (for create command)
  --switch          Switch to the worktree after creating it (for create command)
  --dir <directory> Check the specified directory (for is-worktree command, defaults to current dir)
  --pr-review       Open changed files in tabs for PR review (for switch command)
  --parent <branch> Parent branch for PR review or stack creation (defaults to main)
  --stack           Execute command for entire stack (for push/pr commands)
  --dry-run         Show what would be done without actually doing it (for push/pr commands)
  --draft           Create draft pull requests (for pr --stack)
  --publish         Publish draft PRs to ready state (for pr --stack)
  --force|-f        Force push branches (for push --stack)

Examples:
  wt init
  wt list
  wt create feature/my-feature
  wt create feature/child --parent feature/parent
  wt create --no-symlink experimental/test
  wt create --switch feature/my-feature
  wt switch feature/my-feature
  wt switch feature/my-feature --pr-review
  wt switch feature/my-feature --pr-review --parent develop
  wt rm feature/my-feature
  wt close feature/my-feature  # Remove worktree AND delete branch
  wt close --all  # Remove all worktrees AND delete branches (from main)
  wt merge feature/my-feature
  wt create --quiet bugfix/issue-123
  wt is-worktree
  wt is-worktree --dir /path/to/directory
  wt stack
  wt stack --install
  wt stack move  # Interactive mode
  wt stack move --onto main  # Move current branch onto main
  wt stack move --up  # Move branch up among siblings
  wt stack move --down --dry-run  # Preview moving branch down
  wt stack reorder  # Interactive branch reordering
  wt sync
  wt sync --continue
  wt restack
  wt next
  wt prev
  wt run "npm test"
  wt run "git status"
  wt push --stack --dry-run
  wt push --stack
  wt push --stack --force
  wt pr --stack --dry-run
  wt pr --stack
  wt pr --stack --draft
  wt pr --stack --publish
  wt stack open feature/child  # Creates worktrees for parent branches leading to child
  wt stack open feature/child --create-sessions  # Also creates tmux sessions
  wt migrate-to-gt
  wt modify  # Amend current commit
  wt modify --commit  # Create new commit
  wt modify --all --message "Fix bug"  # Stage all and amend with message

Notes:
  - Requires Graphite (gt) for stack management features
  - Install gt with: brew install graphite (macOS) or see https://graphite.dev
  - For existing git-stack projects, run 'wt migrate-to-gt' once
  - Stack metadata is shared between all worktrees via symlinks
EOF
}

log() {
    if [ "$QUIET" = false ]; then
        echo "$@" >&2
    fi
}

run_cmd() {
    if [ "$QUIET" = true ]; then
        "$@" >/dev/null 2>&1
    else
        "$@"
    fi
}

init_worktrees() {
    log "Initializing worktrees directory..."
    
    if [ ! -d "$PROJECT_DIR/.git" ]; then
        echo "Error: Not in a git repository" >&2
        exit 1
    fi
    
    mkdir -p "$WORKTREES_DIR"
    
    log "Worktrees directory initialized at: $WORKTREES_DIR"
}

list_worktrees() {
    if [ ! -d "$WORKTREES_DIR" ]; then
        echo "No worktrees directory found. Run 'wt init' first."
        return 0
    fi

    echo "Worktrees for $PROJECT_NAME:"
    echo ""

    # Get git worktree list output
    local git_worktrees
    git_worktrees=$(git worktree list --porcelain 2>/dev/null || echo "")

    if [ -z "$git_worktrees" ]; then
        echo "No worktrees found."
        return 0
    fi
    
    # Parse porcelain output
    local worktree_path=""
    local branch=""
    local commit=""
    local is_detached=false
    local is_current=false
    local worktrees_found=false
    
    # Add header
    printf "%-40s %-25s %s\n" "Branch/Worktree" "Status" "Location"
    printf "%s\n" "$(printf '%.0s-' {1..90})"
    
    while IFS= read -r line; do
        if [[ "$line" =~ ^worktree[[:space:]](.+) ]]; then
            # Process previous worktree if exists
            if [ -n "$worktree_path" ]; then
                # Only show worktrees in our worktrees directory or the main project
                if [[ "$worktree_path" == "$WORKTREES_DIR/"* ]] || [[ "$worktree_path" == "$PROJECT_DIR" ]]; then
                    local display_branch=""
                    local display_path=""
                    local status=""
                    
                    # Determine display path
                    if [[ "$worktree_path" == "$PROJECT_DIR" ]]; then
                        display_path="(main project)"
                    else
                        display_path="${worktree_path#$WORKTREES_DIR/}"
                    fi
                    
                    # Build branch display and status
                    if [ "$is_detached" = true ]; then
                        # For detached HEAD, show the short commit SHA
                        if [ -n "$commit" ]; then
                            display_branch="${commit:0:8} (detached)"
                        else
                            display_branch="detached HEAD"
                        fi
                        status="detached"
                    else
                        display_branch="${branch:-unknown}"
                        status="on branch"
                    fi
                    
                    # Mark current
                    if [ "$is_current" = true ]; then
                        status="$status [current]"
                        printf "► %-38s %-25s %s\n" "$display_branch" "$status" "$display_path"
                    else
                        printf "  %-38s %-25s %s\n" "$display_branch" "$status" "$display_path"
                    fi
                    
                    worktrees_found=true
                fi
            fi
            
            # Reset for new worktree
            worktree_path="${BASH_REMATCH[1]}"
            branch=""
            commit=""
            is_detached=false
            is_current=false
            
            # Check if this is the current directory
            if [[ "$(pwd)" == "$worktree_path" ]]; then
                is_current=true
            fi
        elif [[ "$line" =~ ^HEAD[[:space:]](.+) ]]; then
            commit="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^branch[[:space:]]refs/heads/(.+) ]]; then
            branch="${BASH_REMATCH[1]}"
        elif [[ "$line" == "detached" ]]; then
            is_detached=true
        fi
    done <<< "$git_worktrees"
    
    # Process last worktree
    if [ -n "$worktree_path" ]; then
        if [[ "$worktree_path" == "$WORKTREES_DIR/"* ]] || [[ "$worktree_path" == "$PROJECT_DIR" ]]; then
            local display_branch=""
            local display_path=""
            local status=""
            
            # Determine display path
            if [[ "$worktree_path" == "$PROJECT_DIR" ]]; then
                display_path="(main project)"
            else
                display_path="${worktree_path#$WORKTREES_DIR/}"
            fi
            
            # Build branch display and status
            if [ "$is_detached" = true ]; then
                # For detached HEAD, show the short commit SHA
                if [ -n "$commit" ]; then
                    display_branch="${commit:0:8} (detached)"
                else
                    display_branch="detached HEAD"
                fi
                status="detached"
            else
                display_branch="${branch:-unknown}"
                status="on branch"
            fi
            
            # Mark current
            if [ "$is_current" = true ]; then
                status="$status [current]"
                printf "► %-38s %-25s %s\n" "$display_branch" "$status" "$display_path"
            else
                printf "  %-38s %-25s %s\n" "$display_branch" "$status" "$display_path"
            fi
            
            worktrees_found=true
        fi
    fi
    
    if [ "$worktrees_found" = false ]; then
        echo "No worktrees found in $WORKTREES_DIR"
    fi
}

create_worktree() {
    local branch="$1"
    local worktree_path="$WORKTREES_DIR/$branch"
    
    if [ -z "$branch" ]; then
        echo "Error: Branch name is required" >&2
        usage
        return 1
    fi
    
    if [ ! -d "$WORKTREES_DIR" ]; then
        log "Worktrees directory not found. Running init first..."
        init_worktrees
    fi
    
    if [ -d "$worktree_path" ]; then
        echo "Error: Worktree already exists at: $worktree_path" >&2
        return 1
    fi
    
    log "Setting up $branch..."

    # Determine the base branch for the new worktree
    local base_branch="$PARENT_BRANCH"

    # Check if branch exists
    if git show-ref --verify --quiet "refs/heads/$branch"; then
        git worktree add "$worktree_path" "$branch" &>/dev/null
    else
        # Check if it exists as a remote branch
        if git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
            git worktree add "$worktree_path" -b "$branch" "origin/$branch" &>/dev/null
        else
            # Create new branch from the parent branch
            if [ "$base_branch" != "main" ] && [ "$base_branch" != "master" ]; then
                # Ensure parent branch exists
                if git show-ref --verify --quiet "refs/heads/$base_branch"; then
                    git worktree add "$worktree_path" -b "$branch" "$base_branch" &>/dev/null
                else
                    echo "Error: Parent branch '$base_branch' does not exist" >&2
                    return 1
                fi
            else
                git worktree add "$worktree_path" -b "$branch" &>/dev/null
            fi
        fi
    fi
    
    # Initialize gt in the new worktree (silently)
    if command -v gt &>/dev/null; then
        # Determine trunk branch (main or master)
        local trunk_branch="main"
        if ! git show-ref --verify --quiet "refs/heads/main"; then
            if git show-ref --verify --quiet "refs/heads/master"; then
                trunk_branch="master"
            fi
        fi
        gt -C "$worktree_path" repo init --trunk "$trunk_branch" -q &>/dev/null 2>&1 || true

        # Symlink .graphite_repo_config if it exists in main project
        if [ -f "$PROJECT_DIR/.git/.graphite_repo_config" ] && [ ! -e "$worktree_path/.git/.graphite_repo_config" ]; then
            ln -s "$PROJECT_DIR/.git/.graphite_repo_config" "$worktree_path/.git/.graphite_repo_config" &>/dev/null 2>&1 || true
        fi
    fi

    # Configure Graphite parent relationship if parent was explicitly specified (silently)
    if [ "$PARENT_BRANCH" != "main" ] || [[ "${PARENT_BRANCH_EXPLICIT:-false}" == "true" ]]; then
        if command -v gt &>/dev/null; then
            # First ensure the parent branch is tracked
            (cd "$worktree_path" && gt track "$PARENT_BRANCH" &>/dev/null 2>&1) || true
            # Now track the current branch with its parent
            (cd "$worktree_path" && gt track "$branch" --parent "$PARENT_BRANCH" &>/dev/null 2>&1) || true
        fi
    fi

    # Create symlink to .claude directory if it exists in the main project (silently)
    if [ "$NO_SYMLINK" = false ] && [ -d "$PROJECT_DIR/.claude" ]; then
        if [ ! -e "$worktree_path/.claude" ]; then
            ln -s "$PROJECT_DIR/.claude" "$worktree_path/.claude" &>/dev/null 2>&1 || true
        fi
    fi
    
    # Explicitly return success
    return 0
}

remove_worktree() {
    local branch="$1"
    local worktree_path="$WORKTREES_DIR/$branch"
    
    if [ -z "$branch" ]; then
        echo "Error: Branch name is required" >&2
        usage
        exit 1
    fi
    
    if [ ! -d "$worktree_path" ]; then
        echo "Error: Worktree not found at: $worktree_path" >&2
        exit 1
    fi
    
    log "Removing worktree for branch: $branch"
    
    # Get the project name from the current directory
    local project_name=$(basename "$PROJECT_DIR")
    
    # Create session name with worktree info (same format as in switch_worktree)
    # Replace slashes in branch name with dashes to avoid tmux issues
    local safe_branch=$(echo "$branch" | tr '/' '-')
    local session_name="${project_name}-wt-${safe_branch}"
    
    # Check if tmux session exists and kill it
    if tmux has-session -t "$session_name" 2>/dev/null; then
        log "Killing tmux session: $session_name"
        run_cmd tmux kill-session -t "$session_name"
    fi
    
    # Remove the worktree
    run_cmd git worktree remove "$worktree_path" --force
    
    # Clean up any remaining directory if it exists
    if [ -d "$worktree_path" ]; then
        rm -rf "$worktree_path"
    fi
    
    # Prune worktree metadata
    run_cmd git worktree prune
    
    log "Worktree removed: $branch"
}

close_branch() {
    local branch="$1"
    local close_all=false

    # Check for --all flag
    if [ "$branch" = "--all" ]; then
        close_all=true
    fi

    if [ "$close_all" = true ]; then
        # Check if we're in the main branch worktree
        set +e
        (
            CHECK_DIR="$(pwd)"
            is_worktree
        )
        local is_wt_result=$?
        set -e

        if [ $is_wt_result -ne 1 ]; then
            echo "Error: 'wt close --all' must be run from the main branch worktree" >&2
            exit 3
        fi

        # Get list of all worktrees
        local git_worktrees=$(git worktree list --porcelain 2>/dev/null || echo "")
        if [ -z "$git_worktrees" ]; then
            # No worktrees, nothing to do - success with no output
            exit 0
        fi

        local branches_to_close=()
        local worktree_path=""
        local branch=""

        # Parse worktree list to get branches
        while IFS= read -r line; do
            if [[ "$line" =~ ^worktree[[:space:]](.+) ]]; then
                # Process previous worktree if exists
                if [ -n "$worktree_path" ] && [ -n "$branch" ]; then
                    # Only consider worktrees in our worktrees directory (not main project)
                    if [[ "$worktree_path" == "$WORKTREES_DIR/"* ]]; then
                        # Skip main/master branches
                        if [ "$branch" != "main" ] && [ "$branch" != "master" ]; then
                            branches_to_close+=("$branch")
                        fi
                    fi
                fi

                # Reset for new worktree
                worktree_path="${BASH_REMATCH[1]}"
                branch=""
            elif [[ "$line" =~ ^branch[[:space:]]refs/heads/(.+) ]]; then
                branch="${BASH_REMATCH[1]}"
            fi
        done <<< "$git_worktrees"

        # Process last worktree
        if [ -n "$worktree_path" ] && [ -n "$branch" ]; then
            if [[ "$worktree_path" == "$WORKTREES_DIR/"* ]]; then
                if [ "$branch" != "main" ] && [ "$branch" != "master" ]; then
                    branches_to_close+=("$branch")
                fi
            fi
        fi

        # Close each branch silently
        for branch_to_close in "${branches_to_close[@]}"; do
            # Call the internal close logic directly
            _close_single_branch "$branch_to_close"
        done

        # Success - no output
        exit 0
    fi

    if [ -z "$branch" ]; then
        echo "Error: Branch name is required" >&2
        usage
        exit 1
    fi

    # Prevent closing main/master branches
    if [ "$branch" = "main" ] || [ "$branch" = "master" ]; then
        echo "Error: Cannot close main/master branch" >&2
        exit 2
    fi

    # Use the internal function for single branch close
    _close_single_branch "$branch"
}

_close_single_branch() {
    local branch="$1"

    # Check if branch exists locally
    if ! git show-ref --verify --quiet "refs/heads/$branch"; then
        # Silently exit with success if branch doesn't exist
        return 0
    fi

    # Remove worktree if it exists (silently)
    local worktree_path="$WORKTREES_DIR/$branch"
    if [ -d "$worktree_path" ]; then
        # Temporarily set QUIET to true to suppress remove_worktree output
        local orig_quiet="$QUIET"
        QUIET=true
        remove_worktree "$branch"
        QUIET="$orig_quiet"
    fi

    # Delete the local branch (silently)
    if ! git branch -D "$branch" >/dev/null 2>&1; then
        if [ "$QUIET" = false ]; then
            echo "Error: Failed to delete branch '$branch'" >&2
            echo "Branch may be checked out in current directory" >&2
        fi
        return 1
    fi

    # Success - no output
    return 0
}

reset_worktrees() {
    log "Resetting all worktrees for $PROJECT_NAME..."

    # Get list of all worktrees
    local git_worktrees=$(git worktree list --porcelain 2>/dev/null || echo "")

    if [ -z "$git_worktrees" ]; then
        log "No worktrees found to reset."
        return 0
    fi

    local branches_to_close=()
    local worktree_path=""
    local branch=""

    # Parse worktree list to get branches
    while IFS= read -r line; do
        if [[ "$line" =~ ^worktree[[:space:]](.+) ]]; then
            # Process previous worktree if exists
            if [ -n "$worktree_path" ] && [ -n "$branch" ]; then
                # Only consider worktrees in our worktrees directory (not main project)
                if [[ "$worktree_path" == "$WORKTREES_DIR/"* ]]; then
                    # Skip main/master branches
                    if [ "$branch" != "main" ] && [ "$branch" != "master" ]; then
                        branches_to_close+=("$branch")
                    fi
                fi
            fi

            # Reset for new worktree
            worktree_path="${BASH_REMATCH[1]}"
            branch=""
        elif [[ "$line" =~ ^branch[[:space:]]refs/heads/(.+) ]]; then
            branch="${BASH_REMATCH[1]}"
        fi
    done <<< "$git_worktrees"

    # Process last worktree
    if [ -n "$worktree_path" ] && [ -n "$branch" ]; then
        if [[ "$worktree_path" == "$WORKTREES_DIR/"* ]]; then
            if [ "$branch" != "main" ] && [ "$branch" != "master" ]; then
                branches_to_close+=("$branch")
            fi
        fi
    fi

    if [ ${#branches_to_close[@]} -eq 0 ]; then
        log "No worktree branches found to reset."
        return 0
    fi

    log "Found ${#branches_to_close[@]} worktree branches to close:"
    for branch in "${branches_to_close[@]}"; do
        log "  - $branch"
    done
    log ""

    # Confirm with user
    echo -n "This will remove all worktrees and delete their branches. Continue? (y/N): "
    read -r response
    if [ "$response" != "y" ] && [ "$response" != "Y" ]; then
        log "Reset cancelled."
        return 0
    fi

    log ""
    local failed_branches=()

    # Close each branch
    for branch in "${branches_to_close[@]}"; do
        log "Closing branch: $branch"

        # Remove worktree if it exists
        local worktree_path="$WORKTREES_DIR/$branch"
        if [ -d "$worktree_path" ]; then
            # Get the project name from the current directory
            local project_name=$(basename "$PROJECT_DIR")

            # Create session name with worktree info (same format as in switch_worktree)
            # Replace slashes in branch name with dashes to avoid tmux issues
            local safe_branch=$(echo "$branch" | tr '/' '-')
            local session_name="${project_name}-wt-${safe_branch}"

            # Check if tmux session exists and kill it
            if tmux has-session -t "$session_name" 2>/dev/null; then
                log "  Killing tmux session: $session_name"
                tmux kill-session -t "$session_name" 2>/dev/null || true
            fi

            # Remove the worktree
            log "  Removing worktree at: $worktree_path"
            git worktree remove "$worktree_path" --force 2>/dev/null || true

            # Clean up any remaining directory if it exists
            if [ -d "$worktree_path" ]; then
                rm -rf "$worktree_path"
            fi
        fi

        # Delete the local branch
        if git show-ref --verify --quiet "refs/heads/$branch"; then
            log "  Deleting branch: $branch"
            if ! git branch -D "$branch" 2>/dev/null; then
                log "  ✗ Failed to delete branch '$branch' (may be checked out)"
                failed_branches+=("$branch")
            else
                log "  ✓ Branch deleted"
            fi
        fi
    done

    # Prune worktree metadata
    log ""
    log "Pruning worktree metadata..."
    git worktree prune

    if [ ${#failed_branches[@]} -gt 0 ]; then
        log ""
        log "Warning: Failed to delete the following branches:"
        for branch in "${failed_branches[@]}"; do
            log "  - $branch"
        done
        log "These branches may be checked out in the current directory."
        return 1
    else
        log ""
        log "✓ Reset completed successfully!"
        log "All worktrees removed and branches deleted."
    fi
}

switch_worktree() {
    local branch="$1"
    local worktree_path="$WORKTREES_DIR/$branch"
    
    if [ -z "$branch" ]; then
        echo "Error: Branch name is required" >&2
        usage
        return 1
    fi
    
    # Special handling for main/master branch - use project root
    if [ "$branch" = "main" ] || [ "$branch" = "master" ]; then
        worktree_path="$PROJECT_DIR"
        # Check if the branch matches what's actually in the project root
        local project_branch=$(git -C "$PROJECT_DIR" rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [ "$project_branch" != "$branch" ]; then
            echo "Error: Project root is on branch '$project_branch', not '$branch'" >&2
            return 1
        fi
    elif [ ! -d "$worktree_path" ]; then
        echo "Error: Worktree not found at: $worktree_path" >&2
        echo "Available worktrees:" >&2
        if [ -d "$WORKTREES_DIR" ]; then
            ls -1 "$WORKTREES_DIR" 2>/dev/null | sed 's/^/  /' >&2
        fi
        return 1
    fi
    
    log "Switching to worktree: $branch"
    
    # Get the project name from the current directory
    local project_name=$(basename "$PROJECT_DIR")
    
    # Create session name
    if [ "$branch" = "main" ] || [ "$branch" = "master" ]; then
        # Main branch uses just the project name
        local session_name="$project_name"
    else
        # Worktrees use project-wt-branch format
        # Replace slashes in branch name with dashes to avoid tmux issues
        local safe_branch=$(echo "$branch" | tr '/' '-')
        local session_name="${project_name}-wt-${safe_branch}"
    fi
    
    # Check if we're in a tmux session
    if [ -n "${TMUX:-}" ]; then
        # We're in tmux, use proj to switch/create sessions
        # Call proj directly, with optional --pr-review flag
        if [ "$PR_REVIEW" = true ]; then
            # For stack-aware PR review, detect the actual parent branch
            local review_base_branch="$PARENT_BRANCH"
            if [ "$PARENT_BRANCH" = "main" ] || [ "$PARENT_BRANCH" = "master" ]; then
                # If using default, try to detect the actual parent from git config
                local detected_parent=$(get_branch_parent "$branch")
                if [ -n "$detected_parent" ]; then
                    review_base_branch="$detected_parent"
                    log "Using detected parent branch for PR review: $review_base_branch"
                fi
            fi
            proj "$session_name" --path "$worktree_path" --pr-review --base-branch "$review_base_branch"
        else
            proj "$session_name" --path "$worktree_path"
        fi
    else
        # Not in tmux, output the cd command for the user to execute
        # Since we can't change the parent shell's directory from a script
        if [ "$QUIET" = true ]; then
            # In quiet mode, just output the path
            echo "$worktree_path"
        else
            log "Not in tmux session. To switch to the worktree, run:"
            log ""
            echo "cd $worktree_path"
        fi
    fi
}

merge_worktree() {
    local branch="$1"
    local worktree_path="$WORKTREES_DIR/$branch"
    
    if [ -z "$branch" ]; then
        echo "Error: Branch name is required" >&2
        usage
        return 1
    fi
    
    # Check if we're in the parent worktree (not a worktree)
    # Run is_worktree in a subshell to capture exit code
    local is_wt_result
    # Run in a subshell to prevent exit from terminating our script
    # Temporarily disable set -e for this check
    set +e
    (
        CHECK_DIR="$(pwd)"
        is_worktree
    )
    is_wt_result=$?
    set -e
    
    if [ $is_wt_result -eq 0 ]; then
        echo "Error: wt merge must be run from the parent repository, not a worktree" >&2
        return 1
    elif [ $is_wt_result -eq 2 ]; then
        echo "Error: Not in a git repository" >&2
        return 1
    fi
    # is_wt_result == 1 means we're in the project root, which is what we want
    
    # Check if worktree exists
    if [ ! -d "$worktree_path" ]; then
        echo "Error: No worktree found for branch: $branch" >&2
        echo "Available worktrees:" >&2
        if [ -d "$WORKTREES_DIR" ]; then
            ls -1 "$WORKTREES_DIR" 2>/dev/null | sed 's/^/  /' >&2
        fi
        return 2
    fi
    
    log "Merging branch: $branch"
    
    # Get the merge base
    local merge_base=$(git merge-base HEAD "$branch" 2>/dev/null)
    if [ -z "$merge_base" ]; then
        echo "Error: Could not find merge base for branch: $branch" >&2
        return 1
    fi
    
    # Check if fast-forward is possible
    if ! git merge-base --is-ancestor HEAD "$branch" 2>/dev/null; then
        echo "Error: Cannot fast-forward merge. The branch has diverged." >&2
        return 1
    fi
    
    # Get the diff for the merge
    local diff_output=$(git diff "$merge_base".."$branch" 2>/dev/null)
    
    if [ -z "$diff_output" ]; then
        echo "No changes to merge from branch: $branch"
        return 0
    fi
    
    # Generate commit message using Claude
    log "Generating merge commit message..."
    local commit_message=$(echo "$diff_output" | claude -p "Generate a concise merge commit message based on this diff. The message should summarize what changes are being merged. Format: 'Merge <other-branch> -> <current-branch>: <summary of changes>'. Keep it under 72 characters for the first line, and add details below if needed. Give no additional output beyond the commit message. Format according to 'conventional commits' style, providing all information in teh 'conventional commit' specification which is currently avaialable. Include credit to Claude Code as co-author. Do not surround the commit message with quotes, backticks, or other symbols." 2>/dev/null)
    
    if [ -z "$commit_message" ]; then
        # Fallback message if Claude fails
        commit_message="Merge $branch"
    fi
    
    # Perform the merge with squash
    log "Performing merge..."
    if git merge --ff-only --squash "$branch" 2>&1; then
        # Commit with the generated message
        if git commit -m "$commit_message" 2>&1; then
            log "Merge completed successfully"
            
            # Get the current branch (where we merged into)
            local current_branch=$(git rev-parse --abbrev-ref HEAD)
            
            # Rebase any child branches onto the current branch
            rebase_children_after_merge "$branch" "$current_branch"
            
            # Remove the worktree
            log "Removing merged worktree..."
            remove_worktree "$branch"
        else
            echo "Error: Failed to commit merge" >&2
            # Reset the merge
            git merge --abort 2>/dev/null || git reset --hard HEAD 2>/dev/null
            return 1
        fi
    else
        echo "Error: Merge failed" >&2
        return 1
    fi
}

get_worktree_dir() {
    local branch="$1"
    
    if [ -z "$branch" ]; then
        exit 1
    fi
    
    # Special handling for main/master branch - use project root
    if [ "$branch" = "main" ] || [ "$branch" = "master" ]; then
        # Check if the branch matches what's actually in the project root
        local project_branch=$(git -C "$PROJECT_DIR" rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [ "$project_branch" = "$branch" ]; then
            echo "$PROJECT_DIR"
            exit 0
        else
            exit 1
        fi
    fi
    
    # Check for worktree in the standard location
    local worktree_path="$WORKTREES_DIR/$branch"
    if [ -d "$worktree_path" ]; then
        # Verify it's actually a worktree for this branch
        local worktree_branch=$(git -C "$worktree_path" rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [ "$worktree_branch" = "$branch" ]; then
            echo "$worktree_path"
            exit 0
        fi
    fi
    
    exit 1
}

is_worktree() {
    local dir="${CHECK_DIR:-$(pwd)}"
    
    # Get the absolute path
    dir="$(realpath "$dir" 2>/dev/null)" || exit 2
    
    # Check if directory is an immediate child of any DEVPATH directory
    if [[ -n "$DEVPATH" ]]; then
        # Split DEVPATH by colon
        IFS=':' read -ra DEV_DIRS <<< "$DEVPATH"
        for dev_dir in "${DEV_DIRS[@]}"; do
            # Expand the dev_dir path (handle ~ and variables)
            dev_dir="$(eval echo "$dev_dir")"
            dev_dir="$(realpath "$dev_dir" 2>/dev/null)" || continue
            
            # Check if dir is an immediate child of this dev_dir
            local parent_dir="$(dirname "$dir")"
            if [[ "$parent_dir" == "$dev_dir" ]]; then
                # This is a project root directory, not a worktree
                exit 1
            fi
        done
    fi
    
    # Find the git directory by traversing up from the target directory
    local git_dir="$dir"
    while [[ "$git_dir" != "/" ]]; do
        if [[ -d "$git_dir/.git" ]] || [[ -f "$git_dir/.git" ]]; then
            # Check if git worktree list contains this directory
            if git -C "$git_dir" worktree list 2>/dev/null | grep -q "^$dir\s"; then
                exit 0
            else
                exit 2
            fi
        fi
        git_dir="$(dirname "$git_dir")"
    done
    
    # Not in a git repository
    exit 2
}

create_tmux_session_for_worktree() {
    local branch="$1"
    local worktree_path="$2"

    # Get the project name from the current directory
    local project_name=$(basename "$PROJECT_DIR")

    # Create session name
    if [ "$branch" = "main" ] || [ "$branch" = "master" ]; then
        # Main branch uses just the project name
        local session_name="$project_name"
    else
        # Worktrees use project-wt-branch format
        # Replace slashes in branch name with dashes to avoid tmux issues
        local safe_branch=$(echo "$branch" | tr '/' '-')
        local session_name="${project_name}-wt-${safe_branch}"
    fi

    # Check if tmux session already exists
    if tmux has-session -t "$session_name" 2>/dev/null; then
        return 0
    fi

    # Use proj script to create the session with all the proper setup, but don't switch
    # The proj script expects the session name and path
    if ! proj "$session_name" --path "$worktree_path" --no-switch 2>/dev/null; then
        echo "Warning: Failed to create tmux session for $branch" >&2
        return 1
    fi
    return 0
}

open_stack_branches() {
    local target_branch="$1"
    local create_sessions=false

    # Check for --create-sessions flag (passed via global variable)
    if [ "${STACK_CREATE_SESSIONS:-false}" = true ]; then
        create_sessions=true
    fi

    if [ -z "$target_branch" ]; then
        echo "Error: Branch name is required" >&2
        echo "Usage: wt stack open <branch> [--create-sessions]" >&2
        return 1
    fi

    # Check if we're running from the main branch worktree
    set +e
    (
        CHECK_DIR="$(pwd)"
        is_worktree
    )
    local is_wt_result=$?
    set -e

    if [ $is_wt_result -ne 1 ]; then
        echo "Error: 'wt stack open' must be run from the main branch worktree" >&2
        exit 1
    fi

    # Check if gt is available
    if ! command -v gt &>/dev/null; then
        echo "Error: Graphite (gt) is required for stack operations" >&2
        echo "Install with: brew install graphite or visit https://graphite.dev" >&2
        exit 2
    fi

    log "Fetching latest branch information from remote..."
    git fetch origin --quiet 2>/dev/null || log "Warning: Could not fetch from origin"

    # First, ensure the target branch exists locally or remotely
    if ! git show-ref --verify --quiet "refs/heads/$target_branch" && \
       ! git show-ref --verify --quiet "refs/remotes/origin/$target_branch"; then
        echo "Error: Branch '$target_branch' does not exist locally or on origin" >&2
        exit 2
    fi

    # If the branch exists on remote but not locally, fetch it to get its metadata
    if ! git show-ref --verify --quiet "refs/heads/$target_branch" && \
         git show-ref --verify --quiet "refs/remotes/origin/$target_branch"; then
        log "Fetching remote branch and its metadata: $target_branch"
        git fetch origin "$target_branch:$target_branch" 2>/dev/null || true

        # Also fetch the graphite metadata
        git fetch origin "refs/branch-metadata/$target_branch:refs/branch-metadata/$target_branch" 2>/dev/null || true
    fi

    # Initialize gt if needed (this syncs metadata from remote)
    local trunk_branch="main"
    if ! git show-ref --verify --quiet "refs/heads/main"; then
        if git show-ref --verify --quiet "refs/heads/master"; then
            trunk_branch="master"
        fi
    fi

    # Initialize graphite repo if not already done
    if [ ! -f ".git/.graphite_repo_config" ]; then
        log "Initializing Graphite repository..."
        gt repo init --trunk "$trunk_branch" -q 2>/dev/null || true
    fi

    # Sync Graphite metadata from remote
    log "Syncing Graphite metadata..."
    gt repo sync 2>/dev/null || true

    # Get the full stack structure from Graphite
    # This will show all tracked branches, including remote-only ones
    local stack_output=$(gt ls --no-interactive 2>/dev/null || echo "")

    # If stack is still empty, try to track the target branch and its ancestors
    if [ -z "$stack_output" ] || ! echo "$stack_output" | grep -q "$target_branch"; then
        log "Stack information not available, attempting to discover stack from remote..."

        # Try to discover the stack from GitHub PR information if gh is available
        local branches_to_track=()

        if command -v gh &>/dev/null; then
            log "Checking GitHub for PR stack information..."

            # First, discover all branches that are part of the stack
            # We need to find not just ancestors but all related branches
            declare -A all_stack_branches
            declare -A branch_parent_map
            local branches_to_process=("$target_branch")
            local max_iterations=100
            local iterations=0

            # Process branches to discover the full stack
            while [ ${#branches_to_process[@]} -gt 0 ] && [ $iterations -lt $max_iterations ]; do
                local current="${branches_to_process[0]}"
                branches_to_process=("${branches_to_process[@]:1}")  # Remove first element

                # Skip if we've already processed this branch
                if [ "${all_stack_branches[$current]:-}" = "1" ]; then
                    continue
                fi

                all_stack_branches["$current"]=1

                # Fetch the branch if it doesn't exist locally
                if ! git show-ref --verify --quiet "refs/heads/$current"; then
                    if git show-ref --verify --quiet "refs/remotes/origin/$current"; then
                        git fetch origin "$current:$current" 2>/dev/null || true
                    else
                        continue  # Skip branches that don't exist
                    fi
                fi

                # Find parent from GitHub PR
                local pr_info=$(gh pr list --head "$current" --json baseRefName --limit 1 2>/dev/null || echo "")
                if [ -n "$pr_info" ] && [ "$pr_info" != "[]" ]; then
                    local parent=$(echo "$pr_info" | grep -o '"baseRefName":"[^"]*"' | sed 's/"baseRefName":"//' | sed 's/"//')
                    if [ -n "$parent" ]; then
                        branch_parent_map["$current"]="$parent"
                        # Add parent to process list if it's not main/master
                        if [ "$parent" != "main" ] && [ "$parent" != "master" ]; then
                            branches_to_process+=("$parent")
                        fi
                    fi
                fi

                # Find children (other PRs based on this branch)
                local children_info=$(gh pr list --base "$current" --json headRefName 2>/dev/null || echo "")
                if [ -n "$children_info" ] && [ "$children_info" != "[]" ]; then
                    while IFS= read -r child; do
                        if [ -n "$child" ]; then
                            branches_to_process+=("$child")
                        fi
                    done < <(echo "$children_info" | grep -o '"headRefName":"[^"]*"' | sed 's/"headRefName":"//' | sed 's/"//')
                fi

                iterations=$((iterations + 1))
            done

            # Build ordered list from target back to trunk
            branches_to_track=()
            current="$target_branch"
            local visited_in_chain=()
            local max_depth=50
            local depth=0

            while [ -n "$current" ] && [ "$current" != "main" ] && [ "$current" != "master" ] && [ $depth -lt $max_depth ]; do
                # Check for cycles
                for visited in "${visited_in_chain[@]}"; do
                    if [ "$visited" = "$current" ]; then
                        break 2
                    fi
                done

                visited_in_chain+=("$current")
                branches_to_track=("$current" "${branches_to_track[@]}")
                current="${branch_parent_map[$current]:-}"
                depth=$((depth + 1))
            done
        else
            # Fallback: just track the target branch with main as parent
            log "GitHub CLI not available, tracking target branch only..."
            branches_to_track=("$target_branch")

            # Fetch the branch if it doesn't exist locally
            if ! git show-ref --verify --quiet "refs/heads/$target_branch"; then
                if git show-ref --verify --quiet "refs/remotes/origin/$target_branch"; then
                    log "  Fetching branch: $target_branch"
                    git fetch origin "$target_branch:$target_branch" 2>/dev/null || true
                fi
            fi
        fi

        log "Discovered ${#branches_to_track[@]} branches in stack"

        # Track all branches with their discovered parent relationships
        # First, ensure all branches in the parent map are tracked
        for branch in "${!branch_parent_map[@]}"; do
            if git show-ref --verify --quiet "refs/heads/$branch"; then
                gt track "$branch" -q 2>/dev/null || true
            fi
        done

        # Now set the correct parent relationships
        for branch in "${!branch_parent_map[@]}"; do
            if git show-ref --verify --quiet "refs/heads/$branch"; then
                local parent="${branch_parent_map[$branch]}"
                if [ -n "$parent" ]; then
                    gt track "$branch" --parent "$parent" -q 2>/dev/null || true
                fi
            fi
        done

        log "Tracked all branches with Graphite"

        # Get stack output again
        stack_output=$(gt ls --no-interactive 2>/dev/null || echo "")
    fi

    # Check if the target branch exists in the stack
    if ! echo "$stack_output" | grep -q "$target_branch"; then
        echo "Error: Branch '$target_branch' not found in stack" >&2
        echo "Available branches in stack:" >&2
        echo "$stack_output" | grep -E "^[[:space:]]*[│├└]" | sed 's/^[[:space:]]*[│├└][─\s]*/  /' >&2
        exit 2
    fi

    # Build the complete chain of branches from main to target
    # We'll use gt to discover the full ancestry even for remote-only branches
    local branches_to_create=()
    local current="$target_branch"
    local visited_branches=()
    local max_depth=50  # Prevent infinite loops

    # First, ensure the target branch exists locally or remotely
    if ! git show-ref --verify --quiet "refs/heads/$target_branch" && \
       ! git show-ref --verify --quiet "refs/remotes/origin/$target_branch"; then
        echo "Error: Branch '$target_branch' does not exist locally or on origin" >&2
        exit 2
    fi

    # Build the stack by following parent relationships
    while [ -n "$current" ] && [ "$current" != "main" ] && [ "$current" != "master" ] && [ ${#visited_branches[@]} -lt $max_depth ]; do
        # Check for cycles
        for visited in "${visited_branches[@]}"; do
            if [ "$visited" = "$current" ]; then
                echo "Error: Cycle detected in branch stack at '$current'" >&2
                exit 2
            fi
        done

        visited_branches+=("$current")
        branches_to_create=("$current" "${branches_to_create[@]}")

        # Try to get parent from gt metadata, even for remote-only branches
        local parent=""

        # First check if branch exists locally
        if git show-ref --verify --quiet "refs/heads/$current"; then
            # Branch exists locally, use normal get_branch_parent
            parent=$(get_branch_parent "$current")
        else
            # Branch only exists on remote, try to extract parent from gt metadata
            # Fetch the branch to make it available locally (but don't check it out)
            log "Fetching remote branch: $current"
            git fetch origin "$current:refs/remotes/origin/$current" 2>/dev/null || true

            # Try to get parent info from gt by temporarily tracking the remote branch
            # Create a temporary local ref to query gt
            git update-ref "refs/heads/temp-stack-query-$current" "refs/remotes/origin/$current" 2>/dev/null || true

            # Now try to get parent from gt metadata
            parent=$(gt branch info "temp-stack-query-$current" 2>/dev/null | grep "^Parent:" | sed 's/^Parent:[[:space:]]*//' | cut -d' ' -f1) || true

            # Clean up temporary ref
            git update-ref -d "refs/heads/temp-stack-query-$current" 2>/dev/null || true

            # If we still don't have a parent, try parsing the stack output directly
            if [ -z "$parent" ]; then
                # Look for the current branch in the stack output and find its parent
                # The parent is the branch that appears directly above in the tree structure
                parent=$(echo "$stack_output" | awk -v branch="$current" '
                    /^[[:space:]]*[│├└]/ {
                        # Extract branch name from the line
                        gsub(/^[[:space:]]*[│├└][─\s]*/, "")
                        gsub(/[[:space:]]*\(.*\)[[:space:]]*$/, "")
                        gsub(/^[[:space:]]*/, "")
                        gsub(/[[:space:]]*$/, "")

                        if (prev && $0 == branch) {
                            print prev_branch
                            exit
                        }

                        prev = 1
                        prev_branch = $0
                    }
                ')
            fi
        fi

        current="$parent"
    done

    if [ ${#branches_to_create[@]} -eq 0 ]; then
        log "No branches to create - target branch is main/master or has no parents"
        return 0
    fi

    log "Creating worktrees for ${#branches_to_create[@]} branches in stack"

    # Create worktrees for each branch in order
    local created_count=0
    local existing_count=0
    local skipped_count=0
    for branch in "${branches_to_create[@]}"; do
        # Skip graphite-base branches (internal Graphite merge bases)
        if [[ "$branch" =~ ^graphite-base/ ]]; then
            log "Skipping Graphite internal branch: $branch"
            skipped_count=$((skipped_count + 1))
            continue
        fi

        # Check if worktree already exists
        local worktree_path="$WORKTREES_DIR/$branch"
        if [ -d "$worktree_path" ]; then
            existing_count=$((existing_count + 1))
        else
            # Ensure the branch exists locally before creating worktree
            if ! git show-ref --verify --quiet "refs/heads/$branch"; then
                if git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
                    git fetch origin "$branch:$branch" 2>/dev/null || true
                fi
            fi

            if ! create_worktree "$branch"; then
                echo "Error: Failed to create worktree for branch '$branch'" >&2
                exit 3
            fi
            created_count=$((created_count + 1))
        fi

        # Create tmux session if requested
        if [ "$create_sessions" = true ]; then
            create_tmux_session_for_worktree "$branch" "$worktree_path"
        fi
    done

    if [ $created_count -gt 0 ]; then
        log "✓ Created $created_count new worktrees"
    fi
    if [ $existing_count -gt 0 ]; then
        log "✓ $existing_count worktrees already existed"
    fi
    if [ $skipped_count -gt 0 ]; then
        log "✓ Skipped $skipped_count Graphite internal branches"
    fi
    if [ "$create_sessions" = true ]; then
        log "✓ Created tmux sessions for all branches"
    fi
    return 0
}

set_stack_parent() {
    # Handle help first
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        echo "Usage: wt stack parent [<new-parent>] [--restack] [--switch]"
        echo ""
        echo "Show or set the parent branch of the current branch"
        echo ""
        echo "Options:"
        echo "  --restack    Restack the branch hierarchy after setting parent"
        echo "  --switch     Switch to the parent branch's worktree after setting"
        echo "  --help, -h   Show this help message"
        echo ""
        echo "Examples:"
        echo "  wt stack parent              # Show current parent"
        echo "  wt stack parent main          # Set parent to main"
        echo "  wt stack parent feat --restack # Set parent and restack"
        return 0
    fi

    local parent_branch=""
    local do_restack=false
    local do_switch=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --restack)
                do_restack=true
                shift
                ;;
            --switch)
                do_switch=true
                shift
                ;;
            *)
                if [ -z "$parent_branch" ]; then
                    parent_branch="$1"
                else
                    echo "Error: Unexpected argument: $1" >&2
                    echo "Usage: wt stack parent [<new-parent>] [--restack] [--switch]" >&2
                    return 1
                fi
                shift
                ;;
        esac
    done

    # Get current branch
    local current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    if [ -z "$current_branch" ]; then
        echo "Error: Not in a git repository" >&2
        return 1
    fi

    # If no parent branch specified, show the current parent
    if [ -z "$parent_branch" ]; then
        # Check if branch is tracked first
        if ! gt ls --no-interactive 2>/dev/null | grep -q "^[◯◉][[:space:]]*$current_branch"; then
            echo "Branch '$current_branch' is not tracked by Graphite"
            echo "Run 'wt stack parent <parent-branch>' to track it and set a parent"
            return 0
        fi

        local current_parent=$(get_branch_parent "$current_branch")
        if [ -n "$current_parent" ]; then
            echo "Parent of '$current_branch': $current_parent"
        else
            echo "Branch '$current_branch' has no parent"
        fi
        return 0
    fi

    # Check if parent branch exists
    if ! git show-ref --verify --quiet "refs/heads/$parent_branch" && \
       ! git show-ref --verify --quiet "refs/remotes/origin/$parent_branch"; then
        echo "Error: Parent branch '$parent_branch' does not exist locally or on origin" >&2
        return 1
    fi

    # Don't allow setting a branch as its own parent
    if [ "$current_branch" = "$parent_branch" ]; then
        echo "Error: Cannot set a branch as its own parent" >&2
        return 1
    fi

    # Check if gt is available
    if ! command -v gt &>/dev/null; then
        echo "Error: Graphite (gt) is required for stack operations" >&2
        echo "Install with: brew install graphite or visit https://graphite.dev" >&2
        return 2
    fi

    log "Setting parent of '$current_branch' to '$parent_branch'"

    # Check if branch is tracked by Graphite
    local is_tracked=false
    if gt ls --no-interactive 2>/dev/null | grep -q "^[◯◉][[:space:]]*$current_branch"; then
        is_tracked=true
    fi

    if [ "$is_tracked" = false ]; then
        # Branch is not tracked, use gt track
        log "Branch is not tracked, tracking with Graphite..."
        if ! gt track --parent "$parent_branch" -q; then
            echo "Error: Failed to track branch and set parent" >&2
            return 1
        fi
    else
        # Branch is already tracked, use gt move --onto
        log "Moving branch onto new parent..."
        if ! gt move --onto "$parent_branch" --no-interactive; then
            echo "Error: Failed to change parent" >&2
            echo "If there are conflicts, resolve them and run 'wt continue'" >&2
            return 1
        fi
    fi

    log "✓ Parent relationship configured: $current_branch -> $parent_branch"

    # Handle --restack flag
    if [ "$do_restack" = true ]; then
        log "Restacking branches..."
        if ! gt restack --no-interactive; then
            echo "Error: Restack failed" >&2
            echo "If there are conflicts, resolve them and run 'wt continue'" >&2
            return 1
        fi
        log "✓ Stack restacked successfully"
    fi

    # Handle --switch flag
    if [ "$do_switch" = true ]; then
        log "Switching to parent worktree..."
        switch_worktree "$parent_branch"
    fi

    return 0
}

show_worktree_stack() {
    # Check if the --install flag is present
    # This flag triggers automatic installation of git-stack from GitHub releases
    # if it's not already installed on the system
    if [ "${INSTALL_GIT_STACK:-false}" = true ]; then
        install_git_stack
        exit 0
    fi

    # Check if gt (Graphite) is available
    if ! command -v gt &>/dev/null; then
        echo "Error: gt (Graphite) not found. Install with: brew install graphite or visit https://graphite.dev" >&2
        return 1
    fi
    
    # Check if we're in a git repository
    if ! git rev-parse --git-dir &>/dev/null; then
        echo "Error: Not in a git repository" >&2
        return 1
    fi
    
    # Simply pass through to gt ls with color preservation
    # Use --no-interactive to disable pager
    # Check if --current flag is set
    if [ "${STACK_CURRENT:-false}" = true ]; then
        gt ls -s --no-interactive
    else
        gt ls --no-interactive
    fi
}

sync_worktree_stack() {
    local continue_sync=false
    
    # Check for --continue flag
    if [ "$1" = "--continue" ]; then
        continue_sync=true
    fi
    
    # Check if gt is available
    if ! command -v gt &>/dev/null; then
        echo "Error: Graphite (gt) is required for sync operations" >&2
        echo "Install with: brew install graphite or visit https://graphite.dev" >&2
        return 1
    fi
    
    if [ "$continue_sync" = true ]; then
        log "Continuing sync operation..."
        log ""
        
        # Use gt continue for resuming after conflict resolution
        if gt continue; then
            log ""
            log "Sync continued successfully!"
            log ""
            log "Updated stack:"
            gt ls --no-interactive
        else
            echo ""
            echo "Error: Failed to continue sync" >&2
            echo "Resolve any remaining conflicts and try again" >&2
            return 1
        fi
    else
        log "Syncing stack with remote changes..."
        log ""
        
        # Show current stack before syncing
        log "Current stack:"
        gt ls --no-interactive
        log ""
        
        # Run gt sync
        # This will:
        # - Fetch latest changes from remote
        # - Rebase your stack onto the latest trunk
        # - Update each branch in the stack
        if gt sync; then
            log ""
            log "Sync completed successfully!"
            log ""
            log "Updated stack:"
            gt ls --no-interactive
        else
            echo ""
            echo "Error: Sync failed or was aborted" >&2
            echo "You may need to resolve conflicts and run 'wt sync --continue'" >&2
            return 1
        fi
    fi
}

restack_worktree() {
    # Check if gt is available
    if ! command -v gt &>/dev/null; then
        echo "Error: Graphite (gt) is required for restack operations" >&2
        echo "Install with: brew install graphite or visit https://graphite.dev" >&2
        return 1
    fi
    
    log "Restacking branches to fix parent relationships..."
    log ""
    
    # Show current stack before restacking
    log "Current stack:"
    gt ls --no-interactive
    log ""
    
    # Run gt restack
    # This will:
    # - Fix any incorrect parent-child relationships
    # - Rebase branches onto their correct parents
    # - Handle any conflicts that arise
    if gt restack; then
        log ""
        log "Restack completed successfully!"
        log ""
        log "Updated stack:"
        gt ls --no-interactive
    else
        echo ""
        echo "Error: Restack failed or was aborted" >&2
        echo "You may need to resolve conflicts and run 'gt continue'" >&2
        return 1
    fi
}


get_branch_parent() {
    local branch="$1"
    local worktree_path=""

    # First, check if the branch exists locally
    local branch_exists_locally=false
    if git show-ref --verify --quiet "refs/heads/$branch"; then
        branch_exists_locally=true
    fi

    # If branch doesn't exist locally but exists on remote, we need special handling
    if [ "$branch_exists_locally" = false ]; then
        if git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
            # Try to get parent from gt metadata for remote branch
            # Create a temporary local ref to query gt
            git update-ref "refs/heads/temp-parent-query-$branch" "refs/remotes/origin/$branch" 2>/dev/null || true

            # Now try to get parent from gt metadata
            local parent=$(gt branch info "temp-parent-query-$branch" 2>/dev/null | grep "^Parent:" | sed 's/^Parent:[[:space:]]*//' | cut -d' ' -f1) || true

            # Clean up temporary ref
            git update-ref -d "refs/heads/temp-parent-query-$branch" 2>/dev/null || true

            if [ -n "$parent" ]; then
                echo "$parent"
                return 0
            fi

            # If we still don't have parent, try to get it from the stack output
            local stack_output=$(gt ls --no-interactive 2>/dev/null || echo "")
            if [ -n "$stack_output" ]; then
                parent=$(echo "$stack_output" | awk -v branch="$branch" '
                    BEGIN { found = 0; parent_line = "" }
                    {
                        # Remove tree drawing characters and extract branch name
                        line = $0
                        gsub(/^[[:space:]]*[│├└][─\s]*/, "", line)
                        gsub(/[[:space:]]*\(.*\)[[:space:]]*$/, "", line)
                        gsub(/^[[:space:]]*/, "", line)
                        gsub(/[[:space:]]*$/, "", line)

                        if (found == 1 && line != "") {
                            # This is the line after our branch, which is its parent in the tree
                            parent_line = line
                            found = 2
                        }

                        if (line == branch) {
                            found = 1
                        }

                        if (found == 0 && line != "") {
                            # Keep track of the previous branch for parent detection
                            potential_parent = line
                        }
                    }
                    END {
                        if (found == 1 && potential_parent != "") {
                            # Our branch was found and we have a previous branch
                            print potential_parent
                        }
                    }
                ')
            fi

            echo "$parent"
            return 0
        fi
    fi

    # For local branches, proceed with the existing logic
    # Find the worktree path for this branch
    if [ -n "$branch" ]; then
        # Check if it's a worktree branch (handle branches with slashes)
        local potential_worktree="$WORKTREES_DIR/$branch"
        if [ -d "$potential_worktree" ] && [ -f "$potential_worktree/.git" ]; then
            # Make sure it's actually a worktree (has .git file)
            worktree_path="$potential_worktree"
        else
            # Check if we're in the main project and this is the current branch
            local current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
            if [ "$branch" = "$current_branch" ]; then
                if [ -d "$PROJECT_DIR/.git" ]; then
                    worktree_path="$PROJECT_DIR"
                else
                    # We might be in a worktree ourselves, use current directory
                    worktree_path="$(pwd)"
                fi
            fi
        fi
    fi

    # If we still don't have a worktree path, try to use current directory if branch matches
    if [ -z "$worktree_path" ]; then
        local current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [ "$branch" = "$current_branch" ]; then
            worktree_path="$(pwd)"
        else
            # Can't find worktree, but we can still try to get parent from gt directly
            worktree_path="."
        fi
    fi

    # Get the parent branch from Graphite
    # Try using gt branch info first (faster if available)
    local parent=""
    if command -v gt &>/dev/null; then
        # Check if we can query the branch directly
        if [ "$branch_exists_locally" = true ]; then
            # Try to get parent from gt branch info
            local gt_output=$(gt branch info "$branch" 2>/dev/null || (cd "$worktree_path" 2>/dev/null && gt branch info 2>&1))
            parent=$(echo "$gt_output" | grep "^Parent:" | sed 's/^Parent:[[:space:]]*//' | cut -d' ' -f1)
        fi
    fi

    # Fallback to parsing .graphite_repo_config if gt command fails
    if [ -z "$parent" ] && [ -f "$worktree_path/.git/.graphite_repo_config" ]; then
        # Parse JSON config file for branch parent
        # Using grep and sed for compatibility (jq might not be available)
        parent=$(grep -A 10 "\"$branch\"" "$worktree_path/.git/.graphite_repo_config" 2>/dev/null | grep '"parentBranchName"' | head -1 | sed 's/.*"parentBranchName"[[:space:]]*:[[:space:]]*"//' | sed 's/".*//')
    fi

    # Additional fallback: check the main project's .graphite_repo_config
    if [ -z "$parent" ] && [ -f "$PROJECT_DIR/.git/.graphite_repo_config" ]; then
        parent=$(grep -A 10 "\"$branch\"" "$PROJECT_DIR/.git/.graphite_repo_config" 2>/dev/null | grep '"parentBranchName"' | head -1 | sed 's/.*"parentBranchName"[[:space:]]*:[[:space:]]*"//' | sed 's/".*//')
    fi

    echo "$parent"
}

get_branch_children() {
    local branch="$1"
    local children=()
    
    # Use gt metadata to find direct children of the branch
    if command -v gt &>/dev/null; then
        # Read parent metadata directly from git refs - much faster than calling gt branch info
        local metadata_dir="$PROJECT_DIR/.git/refs/branch-metadata"
        
        if [ -d "$metadata_dir" ]; then
            # Find all branches with metadata
            find "$metadata_dir" -type f 2>/dev/null | while read -r metadata_file; do
                # Get branch name from file path
                local candidate="${metadata_file#$metadata_dir/}"
                
                # Skip the branch itself
                [ "$candidate" = "$branch" ] && continue
                
                # Read the metadata blob
                local blob_sha=$(cat "$metadata_file" 2>/dev/null)
                if [ -n "$blob_sha" ]; then
                    # Extract parent from the JSON blob
                    local parent=$(git cat-file -p "$blob_sha" 2>/dev/null | grep '"parentBranchName"' | sed 's/.*"parentBranchName"[[:space:]]*:[[:space:]]*"//' | sed 's/".*//')
                    
                    if [ "$parent" = "$branch" ]; then
                        echo "$candidate"
                    fi
                fi
            done | while read -r child; do
                [ -n "$child" ] && children+=("$child")
                echo "$child"  # Pass through to parent shell
            done
        else
            # Fallback to using gt branch info if metadata directory doesn't exist
            local all_branches=$(git for-each-ref --format='%(refname:short)' refs/heads/)
            
            for candidate in $all_branches; do
                # Skip the branch itself
                [ "$candidate" = "$branch" ] && continue
                
                # Check if this branch's parent is our target branch
                local parent=$(gt branch info "$candidate" 2>/dev/null | grep "Parent:" | sed 's/.*Parent: *//' | cut -d' ' -f1)
                if [ "$parent" = "$branch" ]; then
                    children+=("$candidate")
                fi
            done
        fi
    else
        # Fallback to checking only worktrees if gt is not available
        # Check main project
        local main_branch=$(git -C "$PROJECT_DIR" rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [ -n "$main_branch" ]; then
            local main_parent=$(get_branch_parent "$main_branch")
            if [ "$main_parent" = "$branch" ]; then
                children+=("$main_branch")
            fi
        fi
        
        # Check all worktrees
        if [ -d "$WORKTREES_DIR" ]; then
            for wt in "$WORKTREES_DIR"/*; do
                [ -d "$wt" ] || continue
                local wt_branch=$(git -C "$wt" rev-parse --abbrev-ref HEAD 2>/dev/null)
                if [ -n "$wt_branch" ]; then
                    local wt_parent=$(get_branch_parent "$wt_branch")
                    if [ "$wt_parent" = "$branch" ]; then
                        children+=("$wt_branch")
                    fi
                fi
            done
        fi
    fi
    
    # Output children one per line
    for child in "${children[@]}"; do
        echo "$child"
    done
}

stack_move() {
    # Check for rebase/merge in progress before any operations
    if [ -d "$(git rev-parse --git-dir 2>/dev/null)/rebase-merge" ] || \
       [ -d "$(git rev-parse --git-dir 2>/dev/null)/rebase-apply" ] || \
       [ -f "$(git rev-parse --git-dir 2>/dev/null)/MERGE_HEAD" ]; then
        echo "Error: Cannot move branches while rebase or merge is in progress" >&2
        echo "Complete or abort the current operation first" >&2
        return 129
    fi

    local onto_parent=""
    local move_up=false
    local move_down=false
    local dry_run=false
    local interactive=true

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --onto)
                shift
                if [ $# -eq 0 ]; then
                    echo "Error: --onto requires a parent branch name" >&2
                    return 1
                fi
                onto_parent="$1"
                interactive=false
                shift
                ;;
            --up)
                move_up=true
                interactive=false
                shift
                ;;
            --down)
                move_down=true
                interactive=false
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            -h|--help)
                echo "Usage: wt stack move [options]"
                echo ""
                echo "Options:"
                echo "  --onto <parent>  Move current branch onto a new parent"
                echo "  --up             Move branch up (earlier) among siblings"
                echo "  --down           Move branch down (later) among siblings"
                echo "  --dry-run        Show what would happen without making changes"
                echo ""
                echo "Without options, opens interactive mode (delegates to gt move)"
                return 0
                ;;
            *)
                # Unknown arguments - pass through to gt move
                if [ "$interactive" = true ]; then
                    # Pass unknown arguments to gt move
                    gt move "$@"
                    return $?
                else
                    echo "Error: Unknown option: $1" >&2
                    return 1
                fi
                ;;
        esac
    done

    # Check for conflicting options
    local option_count=0
    [ -n "$onto_parent" ] && option_count=$((option_count + 1))
    [ "$move_up" = true ] && option_count=$((option_count + 1))
    [ "$move_down" = true ] && option_count=$((option_count + 1))

    if [ $option_count -gt 1 ]; then
        echo "Error: Cannot combine --onto, --up, and --down options" >&2
        return 1
    fi

    # Check if gt is available
    if ! command -v gt &>/dev/null; then
        echo "Error: Graphite (gt) is required for stack operations" >&2
        echo "Install with: brew install graphite or visit https://graphite.dev" >&2
        return 2
    fi

    # Get current branch
    local current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    if [ -z "$current_branch" ]; then
        echo "Error: Not in a git repository" >&2
        return 1
    fi

    # Handle interactive mode (no options provided)
    if [ "$interactive" = true ]; then
        log "Opening interactive move mode..."
        gt move
        return $?
    fi

    # Handle --onto option (delegate to gt)
    if [ -n "$onto_parent" ]; then
        # Check if parent branch exists
        if ! git show-ref --verify --quiet "refs/heads/$onto_parent" && \
           ! git show-ref --verify --quiet "refs/remotes/origin/$onto_parent"; then
            echo "Error: Parent branch '$onto_parent' does not exist" >&2
            return 1
        fi

        if [ "$current_branch" = "$onto_parent" ]; then
            echo "Error: Cannot move a branch onto itself" >&2
            return 1
        fi

        if [ "$dry_run" = true ]; then
            log "Dry-run: Would move '$current_branch' onto '$onto_parent'"
            log ""
            log "Current stack structure:"
            gt ls --no-interactive
            log ""
            log "After move, '$current_branch' would have '$onto_parent' as its parent"
            return 0
        fi

        log "Moving '$current_branch' onto '$onto_parent'..."
        if gt move --onto "$onto_parent" --no-interactive; then
            log "✓ Successfully moved '$current_branch' onto '$onto_parent'"
            log ""
            log "Updated stack structure:"
            gt ls --no-interactive
        else
            echo "Error: Failed to move branch" >&2
            echo "If there are conflicts, resolve them and run 'wt continue'" >&2
            return 1
        fi
        return 0
    fi

    # Handle --up/--down options (custom implementation)
    if [ "$move_up" = true ] || [ "$move_down" = true ]; then
        # Check if current branch is tracked
        if ! gt ls --no-interactive 2>/dev/null | grep -q "^[◯◉][[:space:]]*$current_branch"; then
            echo "Error: Branch '$current_branch' is not tracked by Graphite" >&2
            echo "Track it first with: wt stack parent <parent-branch>" >&2
            return 1
        fi

        # Get the parent of the current branch
        local parent=$(get_branch_parent "$current_branch")
        if [ -z "$parent" ]; then
            echo "Error: Could not determine parent of '$current_branch'" >&2
            return 1
        fi

        # Get all siblings (branches with the same parent)
        # Use gt ls to get the stack structure and parse it
        local siblings=()
        local current_index=-1
        local index=0

        # Parse gt ls output to find siblings
        # Format: ◯ branch-name [optional PR info]
        while IFS= read -r line; do
            # Skip empty lines and non-branch lines
            if [[ ! "$line" =~ ^[◯◉][[:space:]]+ ]]; then
                continue
            fi

            # Extract branch name (remove marker and PR info)
            local branch_name=$(echo "$line" | sed 's/^[◯◉][[:space:]]*//; s/[[:space:]].*//')

            # Skip graphite-base branches
            if [[ "$branch_name" == graphite-base/* ]]; then
                continue
            fi

            # Check if this branch has the same parent
            local branch_parent=$(get_branch_parent "$branch_name")
            if [ "$branch_parent" = "$parent" ]; then
                siblings+=("$branch_name")
                if [ "$branch_name" = "$current_branch" ]; then
                    current_index=$index
                fi
                index=$((index + 1))
            fi
        done < <(gt ls --no-interactive 2>/dev/null)

        if [ ${#siblings[@]} -le 1 ]; then
            echo "Error: No siblings found (branches with parent '$parent')" >&2
            return 1
        fi

        if [ $current_index -eq -1 ]; then
            echo "Error: Current branch not found in sibling list" >&2
            return 1
        fi

        # Determine new position
        local new_index
        if [ "$move_up" = true ]; then
            if [ $current_index -eq 0 ]; then
                echo "Error: Already at the top of siblings" >&2
                return 1
            fi
            new_index=$((current_index - 1))
        else  # move_down
            if [ $current_index -eq $((${#siblings[@]} - 1)) ]; then
                echo "Error: Already at the bottom of siblings" >&2
                return 1
            fi
            new_index=$((current_index + 1))
        fi

        local swap_with="${siblings[$new_index]}"

        if [ "$dry_run" = true ]; then
            log "Dry-run: Would swap positions of '$current_branch' and '$swap_with'"
            log ""
            log "Current order of siblings under '$parent':"
            for i in "${!siblings[@]}"; do
                if [ $i -eq $current_index ]; then
                    echo "  $(($i + 1)). ${siblings[$i]} <-- current"
                else
                    echo "  $(($i + 1)). ${siblings[$i]}"
                fi
            done
            log ""
            if [ "$move_up" = true ]; then
                log "After move, '$current_branch' would be above '$swap_with'"
            else
                log "After move, '$current_branch' would be below '$swap_with'"
            fi
            return 0
        fi

        # Use gt reorder to change the order
        # gt reorder expects the branch names in the new order
        log "Reordering siblings under '$parent'..."

        # Build new order array
        local new_order=()
        for i in "${!siblings[@]}"; do
            if [ "$move_up" = true ]; then
                if [ $i -eq $new_index ]; then
                    new_order+=("$current_branch")
                elif [ $i -eq $current_index ]; then
                    new_order+=("$swap_with")
                else
                    new_order+=("${siblings[$i]}")
                fi
            else  # move_down
                if [ $i -eq $current_index ]; then
                    new_order+=("$swap_with")
                elif [ $i -eq $new_index ]; then
                    new_order+=("$current_branch")
                else
                    new_order+=("${siblings[$i]}")
                fi
            fi
        done

        # Execute the reorder
        # Note: gt reorder expects branches in order from bottom to top of stack
        # So we need to reverse the order
        local reversed_order=()
        for ((i=${#new_order[@]}-1; i>=0; i--)); do
            reversed_order+=("${new_order[$i]}")
        done

        if gt reorder --parent "$parent" "${reversed_order[@]}" --no-interactive; then
            log "✓ Successfully reordered branches"
            log ""
            log "Updated stack structure:"
            gt ls --no-interactive
        else
            echo "Error: Failed to reorder branches" >&2
            echo "If there are conflicts, resolve them and run 'wt continue'" >&2
            return 1
        fi
    fi

    return 0
}

navigate_stack() {
    local direction="$1"
    local current_branch=""
    local target_branch=""
    
    # Get current branch
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    if [ -z "$current_branch" ]; then
        echo "Error: Not in a git repository" >&2
        return 1
    fi
    
    case "$direction" in
        next)
            # Get children of current branch
            local children=($(get_branch_children "$current_branch"))
            if [ ${#children[@]} -eq 0 ]; then
                echo "No child branches found for: $current_branch" >&2
                return 1
            elif [ ${#children[@]} -eq 1 ]; then
                target_branch="${children[0]}"
            else
                # Multiple children, show options
                echo "Multiple child branches found:" >&2
                local i=1
                for child in "${children[@]}"; do
                    echo "  $i) $child" >&2
                    ((i++))
                done
                echo -n "Select branch (1-${#children[@]}): " >&2
                read -r selection
                if [[ "$selection" =~ ^[0-9]+$ ]] && [ "$selection" -ge 1 ] && [ "$selection" -le ${#children[@]} ]; then
                    target_branch="${children[$((selection-1))]}"
                else
                    echo "Invalid selection" >&2
                    return 1
                fi
            fi
            ;;
        prev)
            # Get parent of current branch
            target_branch=$(get_branch_parent "$current_branch")
            if [ -z "$target_branch" ]; then
                echo "No parent branch found for: $current_branch" >&2
                return 1
            fi
            ;;
        *)
            echo "Error: Invalid direction: $direction" >&2
            return 1
            ;;
    esac
    
    # Switch to the target branch
    if [ -n "$target_branch" ]; then
        log "Navigating from $current_branch to $target_branch"
        
        # Check if worktree exists for the target branch
        local worktree_path=""
        if [ "$target_branch" = "main" ] || [ "$target_branch" = "master" ]; then
            worktree_path="$PROJECT_DIR"
        else
            worktree_path="$WORKTREES_DIR/$target_branch"
        fi
        
        # If worktree doesn't exist but branch does, create it
        if [ ! -d "$worktree_path" ] && [ "$target_branch" != "main" ] && [ "$target_branch" != "master" ]; then
            # Check if the branch exists
            if git show-ref --verify --quiet "refs/heads/$target_branch" || \
               git show-ref --verify --quiet "refs/remotes/origin/$target_branch"; then
                log "Worktree doesn't exist for $target_branch, creating it..."
                
                # Determine parent branch for the new worktree
                local parent_branch=$(get_branch_parent "$target_branch")
                if [ -z "$parent_branch" ]; then
                    parent_branch="$current_branch"  # Use current branch as parent if not found
                fi
                
                # Save the original parent branch settings
                local original_parent="$PARENT_BRANCH"
                local original_explicit="$PARENT_BRANCH_EXPLICIT"
                
                # Set parent for create_worktree
                PARENT_BRANCH="$parent_branch"
                PARENT_BRANCH_EXPLICIT=true
                
                # Create the worktree
                log "Calling create_worktree for $target_branch..."
                create_worktree "$target_branch"
                local create_result=$?
                log "create_worktree returned with status: $create_result"
                
                # Restore original settings
                PARENT_BRANCH="$original_parent"
                PARENT_BRANCH_EXPLICIT="$original_explicit"
                
                if [ $create_result -eq 0 ]; then
                    # Update worktree_path after creation (in case of slashes in branch name)
                    worktree_path="$WORKTREES_DIR/$target_branch"
                    
                    log "Debug: Checking worktree at path: $worktree_path"
                    
                    # Wait for git to register the worktree and filesystem to settle
                    sleep 0.5
                    
                    # Verify the worktree was created and registered
                    # Use grep -F for literal string matching (handles slashes in paths)
                    local dir_exists=$([ -d "$worktree_path" ] && echo "yes" || echo "no")
                    local in_git_list=$(git worktree list | grep -F -q "$worktree_path" && echo "yes" || echo "no")
                    
                    log "Debug: Directory exists: $dir_exists, In git list: $in_git_list"
                    
                    if [ "$dir_exists" = "yes" ] && [ "$in_git_list" = "yes" ]; then
                        # Now switch to it
                        log "Switching to newly created worktree..."
                        switch_worktree "$target_branch"
                    else
                        log "Warning: Worktree created but not ready yet. Please run the command again."
                        log "Debug: worktree_path=$worktree_path, exists=$dir_exists, in_list=$in_git_list"
                        return 0
                    fi
                else
                    echo "Error: Failed to create worktree for $target_branch" >&2
                    return 1
                fi
            else
                echo "Error: Branch $target_branch does not exist" >&2
                return 1
            fi
        else
            # Worktree exists, just switch to it
            switch_worktree "$target_branch"
        fi
    fi
}

get_stack_branches() {
    local start_branch="${1:-}"
    local branches=()
    local visited=()
    
    # If no start branch specified, get current branch
    if [ -z "$start_branch" ]; then
        start_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [ -z "$start_branch" ]; then
            echo "Error: Not in a git repository" >&2
            return 1
        fi
    fi
    
    # Collect branches by following parent links up from start branch
    local current_branch="$start_branch"
    local stack_branches=()
    
    # Add the starting branch
    stack_branches+=("$current_branch")
    
    # Follow parent links up to the root
    while true; do
        local parent=$(get_branch_parent "$current_branch")
        if [ -z "$parent" ] || [ "$parent" = "$current_branch" ]; then
            # No parent or self-parent means we've reached the root
            break
        fi
        
        # Check if we've seen this branch before (cycle detection)
        for b in "${visited[@]}"; do
            if [ "$b" = "$parent" ]; then
                echo "Error: Cycle detected in branch stack" >&2
                return 1
            fi
        done
        
        visited+=("$current_branch")
        stack_branches+=("$parent")
        current_branch="$parent"
    done
    
    # Reverse the array to get root-to-leaf order
    local reversed_branches=()
    for ((i=${#stack_branches[@]}-1; i>=0; i--)); do
        reversed_branches+=("${stack_branches[$i]}")
    done
    
    # Also include any children of the start branch (to handle the full stack)
    local queue=("$start_branch")
    local processed=("$start_branch")
    
    while [ ${#queue[@]} -gt 0 ]; do
        local current="${queue[0]}"
        queue=("${queue[@]:1}")  # Remove first element
        
        # Get children of current branch
        local children=($(get_branch_children "$current"))
        for child in "${children[@]}"; do
            # Skip if already in our list
            local skip=false
            for b in "${reversed_branches[@]}"; do
                if [ "$b" = "$child" ]; then
                    skip=true
                    break
                fi
            done
            
            if [ "$skip" = false ]; then
                reversed_branches+=("$child")
                queue+=("$child")
            fi
        done
    done
    
    # Output branches
    for branch in "${reversed_branches[@]}"; do
        echo "$branch"
    done
}

run_in_worktree() {
    local branch="$1"
    local command="$2"
    local worktree_path=""
    
    # Determine worktree path
    if [ "$branch" = "main" ] || [ "$branch" = "master" ]; then
        worktree_path="$PROJECT_DIR"
    else
        worktree_path="$WORKTREES_DIR/$branch"
    fi
    
    if [ ! -d "$worktree_path" ]; then
        echo "Error: Directory not found for branch $branch: $worktree_path" >&2
        return 1
    fi
    
    # Run command in the worktree directory
    log "Running in $branch: $command"
    (cd "$worktree_path" && eval "$command")
    local result=$?
    
    if [ $result -eq 0 ]; then
        log "✓ Success in $branch"
    else
        log "✗ Failed in $branch (exit code: $result)"
    fi
    
    return $result
}

run_across_stack() {
    local command="$1"
    
    if [ -z "$command" ]; then
        echo "Error: Command is required" >&2
        usage
        return 1
    fi
    
    # Get all branches in the stack
    local branches=($(get_stack_branches))
    if [ ${#branches[@]} -eq 0 ]; then
        echo "Error: No branches found in stack" >&2
        return 1
    fi
    
    log "Running command across stack: $command"
    log "Branches in order: ${branches[*]}"
    log ""
    
    local failed_branch=""
    
    # Run command in each worktree
    for branch in "${branches[@]}"; do
        if ! run_in_worktree "$branch" "$command"; then
            failed_branch="$branch"
            break
        fi
        log ""
    done
    
    if [ -n "$failed_branch" ]; then
        echo ""
        echo "Error: Command failed in branch: $failed_branch" >&2
        # Find remaining branches after the failed one
        local remaining=()
        local found_failed=false
        for b in "${branches[@]}"; do
            if [ "$found_failed" = true ]; then
                remaining+=("$b")
            elif [ "$b" = "$failed_branch" ]; then
                found_failed=true
            fi
        done
        if [ ${#remaining[@]} -gt 0 ]; then
            echo "Skipped branches: ${remaining[*]}" >&2
        fi
        return 1
    else
        log ""
        log "Command completed successfully across all branches"
    fi
}

rebase_children_after_merge() {
    local merged_branch="$1"
    local new_base_branch="$2"
    
    # Find all children of the merged branch
    local children=($(get_branch_children "$merged_branch"))
    
    if [ ${#children[@]} -eq 0 ]; then
        log "No child branches found for $merged_branch"
        return 0
    fi
    
    log ""
    log "Found ${#children[@]} child branch(es) that need rebasing:"
    for child in "${children[@]}"; do
        log "  - $child"
    done
    log ""
    
    local failed_rebase=""
    
    for child in "${children[@]}"; do
        local child_worktree="$WORKTREES_DIR/$child"
        
        if [ ! -d "$child_worktree" ]; then
            log "✗ Skipping $child - worktree not found"
            continue
        fi
        
        log "Rebasing $child onto $new_base_branch..."
        
        # Save current branch to return to it later
        local current_branch=$(git rev-parse --abbrev-ref HEAD)
        
        # Switch to child worktree and rebase
        if cd "$child_worktree" && git rebase --onto "$new_base_branch" "$merged_branch" "$child" 2>&1; then
            log "✓ Successfully rebased $child"
            
            # Update the parent branch configuration
            git config "branch.$child.stack-base" "$new_base_branch"
            log "✓ Updated parent configuration for $child"
        else
            log "✗ Failed to rebase $child"
            log "  You'll need to manually rebase this branch:"
            log "  cd $child_worktree && git rebase --onto $new_base_branch $merged_branch $child"
            failed_rebase="$child"
            
            # Abort the failed rebase
            git rebase --abort 2>/dev/null || true
        fi
        
        # Return to original directory
        cd - >/dev/null
    done
    
    if [ -n "$failed_rebase" ]; then
        echo ""
        echo "Warning: Some child branches could not be automatically rebased" >&2
        echo "Please resolve conflicts manually" >&2
        return 1
    else
        log ""
        log "All child branches successfully rebased onto $new_base_branch"
        return 0
    fi
}

create_stack_prs() {
    local dry_run=false
    local draft=false
    local publish=false
    
    # Parse PR options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                dry_run=true
                shift
                ;;
            --draft)
                draft=true
                shift
                ;;
            --publish)
                publish=true
                shift
                ;;
            *)
                echo "Error: Unknown option for pr: $1" >&2
                return 1
                ;;
        esac
    done
    
    # Check if gt is available
    if ! command -v gt &>/dev/null; then
        echo "Error: Graphite (gt) is required for stack operations" >&2
        echo "Install with: brew install graphite or visit https://graphite.dev" >&2
        return 1
    fi
    
    log "Creating/updating pull requests for stack using Graphite..."
    log ""
    
    if [ "$dry_run" = true ]; then
        log "Dry run mode - showing what PRs would be created/updated:"
        log ""
        # Show the current stack with PR status
        gt ls --no-interactive
        log ""
        log "Would create/update PRs for all branches in the stack above"
        return 0
    fi
    
    # Prepare gt submit options
    local gt_opts="--no-interactive"
    
    if [ "$draft" = true ]; then
        gt_opts="$gt_opts --draft"
    fi
    
    if [ "$publish" = true ]; then
        gt_opts="$gt_opts --publish"
    fi
    
    # Use gt submit to create/update PRs for the entire stack
    # gt submit handles:
    # - Creating PRs for branches without them
    # - Updating existing PRs
    # - Setting correct base branches automatically
    # - Adding stack context to PR descriptions
    
    log "Running: gt submit $gt_opts"
    log ""
    
    if gt submit $gt_opts; then
        log ""
        log "Pull requests created/updated successfully!"
        log ""
        log "View your PRs:"
        gt ls --no-interactive
    else
        echo ""
        echo "Error: Failed to create/update pull requests" >&2
        echo "Run 'gt status' to see what went wrong" >&2
        return 1
    fi
}

push_stack() {
    local dry_run=false
    local force=false
    
    # Parse push options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                dry_run=true
                shift
                ;;
            --force|-f)
                force=true
                shift
                ;;
            --all)
                # For compatibility, but gt submit handles this automatically
                shift
                ;;
            *)
                echo "Error: Unknown option for push: $1" >&2
                return 1
                ;;
        esac
    done
    
    # Check if gt is available
    if ! command -v gt &>/dev/null; then
        echo "Error: Graphite (gt) is required for stack operations" >&2
        echo "Install with: brew install graphite or visit https://graphite.dev" >&2
        return 1
    fi
    
    log "Pushing stack to remote using Graphite..."
    log ""
    
    if [ "$dry_run" = true ]; then
        log "Dry run mode - showing what would be pushed:"
        log ""
        # Show the current stack
        gt ls --no-interactive
        log ""
        log "Would push all branches in the stack above"
        return 0
    fi
    
    # Use gt submit to push the stack
    # gt submit pushes all branches in the stack
    local gt_opts=""
    if [ "$force" = true ]; then
        gt_opts="--force"
    fi
    
    if gt submit --no-interactive --no-edit $gt_opts; then
        log ""
        log "Stack pushed successfully!"
        log ""
        log "View your PRs with: gt ls"
    else
        echo ""
        echo "Error: Failed to push stack" >&2
        echo "Run 'gt status' to see what went wrong" >&2
        return 1
    fi
}

# Parse command line arguments
COMMAND=""
BRANCH=""
RUN_COMMAND=""
PUSH_STACK=false
PUSH_ALL=false
PUSH_FORCE=false
DRY_RUN=false
PR_STACK=false
PR_DRAFT=false
PR_PUBLISH=false
INSTALL_GIT_STACK=false
STACK_SUBCOMMAND=""
STACK_PARENT_BRANCH=""
STACK_OPEN_BRANCH=""
STACK_CREATE_SESSIONS=false
STACK_CURRENT=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        --quiet)
            QUIET=true
            shift
            ;;
        --stack)
            PUSH_STACK=true
            PR_STACK=true
            shift
            ;;
        --all)
            PUSH_ALL=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --draft)
            PR_DRAFT=true
            shift
            ;;
        --publish)
            PR_PUBLISH=true
            shift
            ;;
        --force|-f)
            PUSH_FORCE=true
            shift
            ;;
        --no-symlink)
            NO_SYMLINK=true
            shift
            ;;
        --switch)
            SWITCH_AFTER_CREATE=true
            shift
            ;;
        --pr-review)
            PR_REVIEW=true
            shift
            ;;
        --parent)
            shift
            if [[ $# -eq 0 ]]; then
                echo "Error: --parent requires a branch name" >&2
                exit 1
            fi
            PARENT_BRANCH="$1"
            PARENT_BRANCH_EXPLICIT=true
            shift
            ;;
        --dir)
            shift
            if [[ $# -eq 0 ]]; then
                echo "Error: --dir requires a directory path" >&2
                exit 1
            fi
            CHECK_DIR="$1"
            shift
            ;;
        --install)
            # Flag to trigger git-stack installation if not already present
            INSTALL_GIT_STACK=true
            shift
            ;;
        init|list|ls|create|rm|close|reset|switch|merge|worktree-dir|is-worktree|stack|sync|restack|next|prev|run|push|pr|migrate-to-gt|modify|continue)
            COMMAND="$1"
            shift
            # For 'close' command, check for --all flag
            if [ "$COMMAND" = "close" ] && [ $# -gt 0 ] && [ "$1" = "--all" ]; then
                BRANCH="--all"
                shift
            # For 'run' command, capture everything else as the command to execute
            elif [ "$COMMAND" = "run" ] && [ $# -gt 0 ]; then
                RUN_COMMAND="$*"
                break
            # For 'modify' command, pass all remaining arguments to gt
            elif [ "$COMMAND" = "modify" ]; then
                break
            fi
            # For 'stack' command, check if there's a subcommand
            if [ "$COMMAND" = "stack" ] && [ $# -gt 0 ]; then
                case "$1" in
                    parent)
                        STACK_SUBCOMMAND="parent"
                        shift
                        # Collect all remaining arguments for set_stack_parent
                        STACK_PARENT_ARGS=("$@")
                        break  # Don't process further arguments
                        ;;
                    open)
                        STACK_SUBCOMMAND="open"
                        shift
                        # Parse remaining arguments for 'stack open'
                        while [ $# -gt 0 ]; do
                            case "$1" in
                                --create-sessions)
                                    STACK_CREATE_SESSIONS=true
                                    shift
                                    ;;
                                --help|-h)
                                    echo "Usage: wt stack open <branch> [--create-sessions]"
                                    echo ""
                                    echo "Create worktrees for all branches in the stack up to the given branch."
                                    echo "Must be run from main branch worktree."
                                    echo ""
                                    echo "Options:"
                                    echo "  --create-sessions  Also create tmux sessions for each worktree (without switching)"
                                    exit 0
                                    ;;
                                --*)
                                    echo "Error: Unknown option for 'stack open': $1" >&2
                                    exit 1
                                    ;;
                                *)
                                    # This is the branch name
                                    if [ -z "$STACK_OPEN_BRANCH" ]; then
                                        STACK_OPEN_BRANCH="$1"
                                        shift
                                    else
                                        echo "Error: Multiple branch names specified" >&2
                                        exit 1
                                    fi
                                    ;;
                            esac
                        done
                        ;;
                    move)
                        STACK_SUBCOMMAND="move"
                        shift
                        # Collect all remaining arguments for stack_move
                        STACK_MOVE_ARGS=("$@")
                        break  # Don't process further arguments
                        ;;
                    reorder)
                        STACK_SUBCOMMAND="reorder"
                        shift
                        # No additional arguments needed for reorder
                        break
                        ;;
                    --current)
                        STACK_CURRENT=true
                        shift
                        ;;
                    --install)
                        # Already handled by the --install flag
                        ;;
                    *)
                        # Not a recognized subcommand, might be a different argument
                        ;;
                esac
            fi
            ;;
        -h|--help|help)
            usage
            exit 0
            ;;
        *)
            # If we have a command that expects a branch and no branch is set yet,
            # treat this as the branch name
            if [[ -n "$COMMAND" ]] && [[ -z "$BRANCH" ]] && [[ "$COMMAND" =~ ^(create|rm|close|switch|merge|worktree-dir|sync)$ ]]; then
                BRANCH="$1"
                shift
            else
                echo "Error: Unknown argument: $1" >&2
                usage
                exit 1
            fi
            ;;
    esac
done

# Execute the appropriate command
case "$COMMAND" in
    init)
        init_worktrees
        ;;
    list|ls)
        list_worktrees
        ;;
    create)
        create_worktree "$BRANCH"
        if [ "$SWITCH_AFTER_CREATE" = true ]; then
            switch_worktree "$BRANCH"
        fi
        ;;
    rm)
        remove_worktree "$BRANCH"
        ;;
    close)
        # Check if first argument is --all
        if [ "$BRANCH" = "--all" ]; then
            close_branch "--all"
        else
            close_branch "$BRANCH"
        fi
        ;;
    reset)
        reset_worktrees
        ;;
    switch)
        switch_worktree "$BRANCH"
        ;;
    merge)
        merge_worktree "$BRANCH"
        ;;
    worktree-dir)
        get_worktree_dir "$BRANCH"
        ;;
    is-worktree)
        is_worktree
        ;;
    stack)
        # Check if there's a subcommand
        if [ "$STACK_SUBCOMMAND" = "parent" ]; then
            # Pass all collected arguments to set_stack_parent
            set_stack_parent "${STACK_PARENT_ARGS[@]}"
        elif [ "$STACK_SUBCOMMAND" = "open" ]; then
            if [ -z "$STACK_OPEN_BRANCH" ]; then
                echo "Error: Branch name is required" >&2
                echo "Usage: wt stack open <branch> [--create-sessions]" >&2
                exit 1
            fi
            open_stack_branches "$STACK_OPEN_BRANCH"
        elif [ "$STACK_SUBCOMMAND" = "move" ]; then
            stack_move "${STACK_MOVE_ARGS[@]}"
        elif [ "$STACK_SUBCOMMAND" = "reorder" ]; then
            # Check if gt is available
            if ! command -v gt &>/dev/null; then
                echo "Error: Graphite (gt) is required for stack operations" >&2
                echo "Install with: brew install graphite or visit https://graphite.dev" >&2
                exit 2
            fi
            # Pure delegation to gt reorder
            log "Opening interactive reorder mode..."
            if ! gt reorder; then
                echo "Error: Failed to reorder branches" >&2
                echo "If there are conflicts, resolve them and run 'wt continue'" >&2
                exit 1
            fi
        else
            show_worktree_stack
        fi
        ;;
    sync)
        sync_worktree_stack "$BRANCH"
        ;;
    restack)
        restack_worktree
        ;;
    next)
        navigate_stack "next"
        ;;
    prev)
        navigate_stack "prev"
        ;;
    run)
        run_across_stack "$RUN_COMMAND"
        ;;
    push)
        if [ "$PUSH_STACK" = true ]; then
            # Build options array
            push_opts=()
            [ "$PUSH_ALL" = true ] && push_opts+=("--all")
            [ "$PUSH_FORCE" = true ] && push_opts+=("--force")
            [ "$DRY_RUN" = true ] && push_opts+=("--dry-run")
            push_stack "${push_opts[@]}"
        else
            echo "Error: push command requires --stack flag" >&2
            echo "Usage: wt push --stack [--force] [--dry-run]" >&2
            exit 1
        fi
        ;;
    pr)
        if [ "$PR_STACK" = true ]; then
            # Build options array
            pr_opts=()
            [ "$DRY_RUN" = true ] && pr_opts+=("--dry-run")
            [ "$PR_DRAFT" = true ] && pr_opts+=("--draft")
            [ "$PR_PUBLISH" = true ] && pr_opts+=("--publish")
            create_stack_prs "${pr_opts[@]}"
        else
            echo "Error: pr command requires --stack flag" >&2
            echo "Usage: wt pr --stack [--draft] [--publish] [--dry-run]" >&2
            exit 1
        fi
        ;;
    migrate-to-gt)
        # Run the migration script
        if [ -f "${SCRIPT_DIR}/wt-migrate-to-gt" ]; then
            "${SCRIPT_DIR}/wt-migrate-to-gt" "$@"
        else
            echo "Error: Migration script not found at ${SCRIPT_DIR}/wt-migrate-to-gt" >&2
            exit 1
        fi
        ;;
    modify)
        # Check if gt is available
        if ! command -v gt &>/dev/null; then
            echo "Error: Graphite (gt) is required for modify operations" >&2
            echo "Install with: brew install graphite or visit https://graphite.dev" >&2
            exit 2
        fi

        # Pass all remaining arguments to gt modify
        # Note: We don't process flags, just pass them through
        gt modify "$@"
        exit $?
        ;;
    "")
        echo "Error: No command specified" >&2
        usage
        exit 1
        ;;
    *)
        echo "Error: Unknown command: $COMMAND" >&2
        usage
        exit 1
        ;;
esac

