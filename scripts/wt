#!/bin/bash

set -euo pipefail

# Get script directory and preserve it
MAIN_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCRIPT_DIR="${MAIN_SCRIPT_DIR}"
LIB_DIR="${MAIN_SCRIPT_DIR}/wt-lib"

# Source library files
source "${LIB_DIR}/common.sh"
source "${LIB_DIR}/worktree.sh"
source "${LIB_DIR}/stack.sh"
source "${LIB_DIR}/create.sh"
source "${LIB_DIR}/close.sh"
source "${LIB_DIR}/stack-advanced.sh"
source "${LIB_DIR}/merge.sh"
source "${LIB_DIR}/tmux.sh"
source "${LIB_DIR}/pr.sh"

# Source the install_git_stack script if it exists
if [ -f "${MAIN_SCRIPT_DIR}/../install_git_stack.sh" ]; then
    source "${MAIN_SCRIPT_DIR}/../install_git_stack.sh"
fi

# Initialize flags (these are used by library functions)
QUIET=false
NO_SYMLINK=false
CHECK_DIR=""
PR_REVIEW=false
# Default parent branch to current branch instead of main
PARENT_BRANCH="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'main')"
PARENT_BRANCH_EXPLICIT=false
SWITCH_AFTER_CREATE=false
INSERT_BRANCH=false
STAGE_ALL=false
NO_VERIFY=false
COMMIT_MESSAGE=""
CHANGE_SUBCOMMAND=""

usage() {
    cat << EOF
Usage: wt <command> [options]

Commands:
  init              Set up the worktrees directory
  list              List all worktrees for the current project
  ls                List all worktrees (alias for list)
  create <branch>   Create a worktree for the specified branch
                    (symlinks .claude/ directory from main project if present)
                    --parent <branch>: specify parent branch (default: current branch)
                    --insert: insert new branch between current and its children
                    --switch: switch to the worktree after creating it
                    --message, -m <msg>: commit message for initial commit
                    --all, -a: stage all changes before creating
                    --no-verify: skip git hooks
                    --no-symlink: do not create symlink to .claude directory
  rm <branch>       Remove the worktree for the specified branch
  close <branch>    Remove worktree and delete the local branch
                    (Cannot be used on main/master branches)
  close --all       Remove all worktrees and delete their branches
                    (Must be run from main branch worktree, skips main/master)
  reset             Remove all worktrees and delete their branches
                    (Skips main/master branches)
  switch <branch>   Change to the worktree for the specified branch
                    (In tmux: switches/creates session. Outside tmux: shows cd command)
  merge <branch>    Merge a worktree branch (must be run from parent repo)
  worktree-dir <branch>  Get the directory path for a branch's worktree
                    Exit codes: 0=found (prints path), 1=not found (no output)
  is-worktree       Check if a directory is a git worktree
                    Exit codes: 0=worktree, 1=project root, 2=neither
  stack             Show all tracked branches and their relationships (gt ls)
  stack --current   Show only the current branch's stack (gt ls -s)
  stack --install   Install Graphite (gt) if not already installed
                    Downloads and installs Graphite from https://graphite.dev
  stack parent [branch] Show or set the parent branch for the current branch
  stack track       Track a branch with Graphite (delegates to gt track)
                    --parent <branch>: set parent branch when tracking
  stack open <branch>    Create worktrees for all branches in the stack up to the given branch
                    Must be run from main branch worktree
  stack open --create-sessions  Also create tmux sessions for each worktree (without switching)
  stack move        Change a branch's parent or reorder siblings
                    --onto <parent>: move to new parent (delegates to gt)
                    --up/--down: reorder among siblings
                    --dry-run: preview changes without applying
  stack reorder     Rearrange multiple branches in the stack interactively (delegates to gt)
  stack rename      Rename the current branch (delegates to gt rename)
                    --force, -f: allow renaming branch with open PR
  stack push        Push all branches in the stack using Graphite (gt submit)
                    --force, -f: force push branches
                    --dry-run: show what would be pushed without pushing
  sync              Sync the stack with remote changes using Graphite (gt sync)
  sync --continue   Continue a sync operation after resolving conflicts (gt continue)
  restack           Fix stack relationships and rebase onto correct parents (gt restack)
  next              Navigate to a child branch in the stack (switch tmux session)
  prev              Navigate to the parent branch in the stack (switch tmux session)
  run <command>     Execute a command across all branches in the stack (in dependency order)
  pr --stack        Create/update pull requests for the stack using Graphite
  migrate-to-gt     Migrate existing git-stack metadata to Graphite format
                    One-time migration for projects using git-stack
  change amend      Amend current commit with auto-restacking (delegates to gt modify)
  change absorb     Auto-apply changes to relevant commits in stack (delegates to gt absorb)
                    --all, -a: stage all changes before absorbing
                    --dry-run, -d: preview where changes would be absorbed
                    --patch, -p: pick hunks to stage before absorbing
  change split      Split current branch into multiple branches (delegates to gt split)
                    --by-commit, -c: split by existing commits
                    --by-hunk, -h: interactively split by hunks
  change squash     Squash all commits in branch into one (delegates to gt squash)
                    --message, -m: updated message for squashed commit
                    --no-edit, -n: don't modify commit message
  continue          Resume paused operation after resolving conflicts (delegates to gt)
                    --abort: abort the current operation

Options:
  --quiet           Suppress output from script and subcommands
  --no-symlink      Do not create symlink to .claude directory (for create command)
  --switch          Switch to the worktree after creating it (for create command)
  --insert          Insert new branch between current and its children (for create command)
  --message, -m     Commit message for initial commit (for create --insert)
  --all, -a         Stage all changes before creating (for create --insert)
  --no-verify       Skip git hooks (for create --insert)
  --dir <directory> Check the specified directory (for is-worktree command, defaults to current dir)
  --project-dir <path> Override project directory for worktree location
                    (worktrees go to ~/.local/worktrees/<project-name>/)
  --pr-review       Open changed files in tabs for PR review (for switch command)
  --parent <branch> Parent branch for PR review or stack creation (defaults to main)
  --stack           Execute command for entire stack (for pr commands)
  --dry-run         Show what would be done without actually doing it (for stack push/pr commands)
  --draft           Create draft pull requests (for pr --stack)
  --publish         Publish draft PRs to ready state (for pr --stack)

Examples:
  wt init
  wt list
  wt create feature/my-feature
  wt create feature/child --parent feature/parent
  wt create feature/middle --insert  # Insert between current branch and children
  wt create feature/new --insert --switch  # Insert and switch
  wt create feature/commit --insert -m "Initial commit"  # With commit message
  wt create --no-symlink experimental/test
  wt create --switch feature/my-feature
  wt switch feature/my-feature
  wt switch feature/my-feature --pr-review
  wt switch feature/my-feature --pr-review --parent develop
  wt rm feature/my-feature
  wt close feature/my-feature  # Remove worktree AND delete branch
  wt close --all  # Remove all worktrees AND delete branches (from main)
  wt merge feature/my-feature
  wt create --quiet bugfix/issue-123
  wt is-worktree
  wt is-worktree --dir /path/to/directory
  wt stack
  wt stack --install
  wt stack track --parent main  # Track current branch with parent
  wt stack move  # Interactive mode
  wt stack move --onto main  # Move current branch onto main
  wt stack move --up  # Move branch up among siblings
  wt stack move --down --dry-run  # Preview moving branch down
  wt stack reorder  # Interactive branch reordering
  wt sync
  wt sync --continue
  wt restack
  wt next
  wt prev
  wt run "npm test"
  wt run "git status"
  wt stack push --dry-run
  wt stack push
  wt stack push --force
  wt pr --stack --dry-run
  wt pr --stack
  wt pr --stack --draft
  wt pr --stack --publish
  wt stack open feature/child  # Creates worktrees for parent branches leading to child
  wt stack open feature/child --create-sessions  # Also creates tmux sessions
  wt stack rename new-name  # Rename current branch
  wt stack rename --force  # Force rename even with open PR
  wt migrate-to-gt
  wt change amend  # Amend current commit
  wt change amend --commit  # Create new commit
  wt change amend --all --message "Fix bug"  # Stage all and amend with message
  wt change split --by-commit  # Split branch by commits
  wt change split --by-hunk  # Interactively split by hunks
  wt change squash -m "New message"  # Squash commits with new message
  wt continue  # Resume after resolving conflicts
  wt continue --abort  # Abort the current operation

Notes:
  - Requires Graphite (gt) for stack management features
  - Install gt with: brew install graphite (macOS) or see https://graphite.dev
  - For existing git-stack projects, run 'wt migrate-to-gt' once
  - Stack metadata is shared between all worktrees via symlinks
EOF
}

# log() and run_cmd() are now provided by common.sh

# init_worktrees() is now provided by worktree.sh

# list_worktrees() is now provided by worktree.sh

# create_worktree() is now provided by create.sh

# remove_worktree() is now provided by worktree.sh

# close_branch() is now provided by close.sh

# _close_single_branch() is now provided by close.sh

# reset_worktrees() is now provided by close.sh

# switch_worktree() is now provided by worktree.sh

# merge_worktree() is now provided by merge.sh

# get_worktree_dir() is now provided by worktree.sh

# is_worktree() is now provided by worktree.sh

# create_tmux_session_for_worktree() is now provided by tmux.sh

# open_stack_branches() is now provided by stack-advanced.sh

# set_stack_parent() is now provided by stack.sh

# show_worktree_stack() is now provided by stack.sh

# sync_worktree_stack() is now provided by stack.sh

# restack_worktree() is now provided by stack.sh


# get_branch_parent() is now provided by stack.sh

# get_branch_children() is now provided by stack-advanced.sh

# stack_move() is now provided by stack.sh

# navigate_stack() is now provided by stack-advanced.sh

# get_stack_branches() is now provided by stack-advanced.sh

# run_in_worktree() is now provided by stack-advanced.sh

# run_across_stack() is now provided by stack-advanced.sh

# rebase_children_after_merge() is now provided by merge.sh

# create_stack_prs() is now provided by pr.sh

# push_stack() is now provided by pr.sh

# Parse command line arguments
COMMAND=""
BRANCH=""
RUN_COMMAND=""
DRY_RUN=false
PR_STACK=false
PR_DRAFT=false
PR_PUBLISH=false
INSTALL_GIT_STACK=false
STACK_SUBCOMMAND=""
STACK_PARENT_BRANCH=""
STACK_OPEN_BRANCH=""
STACK_CREATE_SESSIONS=false
STACK_CURRENT=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        --quiet)
            QUIET=true
            shift
            ;;
        --stack)
            PR_STACK=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --draft)
            PR_DRAFT=true
            shift
            ;;
        --publish)
            PR_PUBLISH=true
            shift
            ;;
        --no-symlink)
            NO_SYMLINK=true
            shift
            ;;
        --switch)
            SWITCH_AFTER_CREATE=true
            shift
            ;;
        --insert)
            INSERT_BRANCH=true
            shift
            ;;
        --message|-m)
            shift
            if [[ $# -eq 0 ]]; then
                echo "Error: --message requires a commit message" >&2
                exit 1
            fi
            COMMIT_MESSAGE="$1"
            shift
            ;;
        --all|-a)
            STAGE_ALL=true
            shift
            ;;
        --no-verify)
            NO_VERIFY=true
            shift
            ;;
        --pr-review)
            PR_REVIEW=true
            shift
            ;;
        --parent)
            shift
            if [[ $# -eq 0 ]]; then
                echo "Error: --parent requires a branch name" >&2
                exit 1
            fi
            PARENT_BRANCH="$1"
            PARENT_BRANCH_EXPLICIT=true
            shift
            ;;
        --dir)
            shift
            if [[ $# -eq 0 ]]; then
                echo "Error: --dir requires a directory path" >&2
                exit 1
            fi
            CHECK_DIR="$1"
            shift
            ;;
        --project-dir)
            shift
            if [[ $# -eq 0 ]]; then
                echo "Error: --project-dir requires a directory path" >&2
                exit 1
            fi
            # Override PROJECT_DIR from common.sh
            PROJECT_DIR="$1"
            PROJECT_NAME="$(basename "$PROJECT_DIR")"
            WORKTREES_DIR="${HOME}/.local/worktrees/$PROJECT_NAME"
            shift
            ;;
        --install)
            # Flag to trigger git-stack installation if not already present
            INSTALL_GIT_STACK=true
            shift
            ;;
        init|list|ls|create|rm|close|reset|switch|merge|worktree-dir|is-worktree|stack|sync|restack|next|prev|run|pr|migrate-to-gt|change|continue)
            COMMAND="$1"
            shift
            # For 'close' command, check for --all flag
            if [ "$COMMAND" = "close" ] && [ $# -gt 0 ] && [ "$1" = "--all" ]; then
                BRANCH="--all"
                shift
            # For 'run' command, capture everything else as the command to execute
            elif [ "$COMMAND" = "run" ] && [ $# -gt 0 ]; then
                RUN_COMMAND="$*"
                break
            # For 'continue' command, pass all remaining arguments (including --abort) to gt
            elif [ "$COMMAND" = "continue" ]; then
                break
            # For 'change' command, capture subcommand and pass remaining args
            elif [ "$COMMAND" = "change" ]; then
                # Don't consume the subcommand here - let wt-change handle it
                if [ $# -gt 0 ]; then
                    CHANGE_SUBCOMMAND="$1"
                    # Don't shift - we need to pass this to wt-change
                fi
                break
            fi
            # For 'stack' command, pass all remaining arguments to wt-stack
            if [ "$COMMAND" = "stack" ]; then
                break  # Don't process further arguments, let wt-stack handle them
            fi
            ;;
        -h|--help|help)
            usage
            exit 0
            ;;
        *)
            # If we have a command that expects a branch and no branch is set yet,
            # treat this as the branch name
            if [[ -n "$COMMAND" ]] && [[ -z "$BRANCH" ]] && [[ "$COMMAND" =~ ^(create|rm|close|switch|merge|worktree-dir|sync)$ ]]; then
                BRANCH="$1"
                shift
            else
                echo "Error: Unknown argument: $1" >&2
                usage
                exit 1
            fi
            ;;
    esac
done

# Skip execution if being sourced by another script
if [ "${WT_SOURCED_ONLY:-false}" = true ]; then
    return 0 2>/dev/null || true
fi

# If --project-dir was provided, change to that directory for git operations
# This ensures git commands operate on the correct repository
if [ -n "${PROJECT_DIR:-}" ] && [ "$PROJECT_DIR" != "$(pwd)" ]; then
    if [ -d "$PROJECT_DIR" ]; then
        cd "$PROJECT_DIR" || { echo "Error: Cannot change to project directory: $PROJECT_DIR" >&2; exit 1; }
    else
        echo "Error: Project directory does not exist: $PROJECT_DIR" >&2
        exit 1
    fi
fi

# Execute the appropriate command
case "$COMMAND" in
    init)
        init_worktrees
        ;;
    list|ls)
        list_worktrees
        ;;
    create)
        create_worktree "$BRANCH"
        if [ "$SWITCH_AFTER_CREATE" = true ]; then
            switch_worktree "$BRANCH"
        fi
        ;;
    rm)
        remove_worktree "$BRANCH"
        ;;
    close)
        # Check if first argument is --all
        if [ "$BRANCH" = "--all" ]; then
            close_branch "--all"
            exit $?
        else
            close_branch "$BRANCH"
            exit $?
        fi
        ;;
    reset)
        reset_worktrees
        ;;
    switch)
        switch_worktree "$BRANCH"
        ;;
    merge)
        merge_worktree "$BRANCH"
        ;;
    worktree-dir)
        get_worktree_dir "$BRANCH"
        ;;
    is-worktree)
        is_worktree
        ;;
    stack)
        # Delegate to wt-stack script (use MAIN_SCRIPT_DIR to avoid overwrite issues)
        if [ -f "${MAIN_SCRIPT_DIR}/wt-subcommands/wt-stack" ]; then
            # Pass QUIET environment variable if set
            export QUIET
            export STACK_CREATE_SESSIONS
            "${MAIN_SCRIPT_DIR}/wt-subcommands/wt-stack" "$@"
            exit $?
        else
            echo "Error: wt-stack script not found at ${MAIN_SCRIPT_DIR}/wt-subcommands/wt-stack" >&2
            exit 1
        fi
        ;;
    sync)
        # Delegate to wt-stack for sync
        if [ -f "${MAIN_SCRIPT_DIR}/wt-subcommands/wt-stack" ]; then
            export QUIET
            "${MAIN_SCRIPT_DIR}/wt-subcommands/wt-stack" sync "$@"
            exit $?
        else
            echo "Error: wt-stack script not found" >&2
            exit 1
        fi
        ;;
    restack)
        # Delegate to wt-stack for restack
        if [ -f "${MAIN_SCRIPT_DIR}/wt-subcommands/wt-stack" ]; then
            export QUIET
            "${MAIN_SCRIPT_DIR}/wt-subcommands/wt-stack" restack "$@"
            exit $?
        else
            echo "Error: wt-stack script not found" >&2
            exit 1
        fi
        ;;
    next)
        navigate_stack "next"
        ;;
    prev)
        navigate_stack "prev"
        ;;
    run)
        run_across_stack "$RUN_COMMAND"
        ;;
    pr)
        if [ "$PR_STACK" = true ]; then
            # Build options array
            pr_opts=()
            [ "$DRY_RUN" = true ] && pr_opts+=("--dry-run")
            [ "$PR_DRAFT" = true ] && pr_opts+=("--draft")
            [ "$PR_PUBLISH" = true ] && pr_opts+=("--publish")
            create_stack_prs "${pr_opts[@]}"
        else
            echo "Error: pr command requires --stack flag" >&2
            echo "Usage: wt pr --stack [--draft] [--publish] [--dry-run]" >&2
            exit 1
        fi
        ;;
    migrate-to-gt)
        # Run the migration script
        if [ -f "${MAIN_SCRIPT_DIR}/wt-subcommands/wt-migrate-to-gt" ]; then
            "${MAIN_SCRIPT_DIR}/wt-subcommands/wt-migrate-to-gt" "$@"
            exit $?
        else
            echo "Error: Migration script not found at ${MAIN_SCRIPT_DIR}/wt-subcommands/wt-migrate-to-gt" >&2
            exit 1
        fi
        ;;
    change)
        # Delegate to wt-change script in subcommands directory
        if [ -f "${MAIN_SCRIPT_DIR}/wt-subcommands/wt-change" ]; then
            # Pass QUIET environment variable if set
            export QUIET
            "${MAIN_SCRIPT_DIR}/wt-subcommands/wt-change" "$@"
            exit $?
        else
            echo "Error: wt-change script not found at ${MAIN_SCRIPT_DIR}/wt-subcommands/wt-change" >&2
            exit 1
        fi
        ;;
    continue)
        # Check if gt is available
        if ! command -v gt &>/dev/null; then
            echo "Error: Graphite (gt) is required for continue operations" >&2
            echo "Install with: brew install graphite or visit https://graphite.dev" >&2
            exit 2
        fi

        # Check for --abort flag
        if [ "${1:-}" = "--abort" ]; then
            log "Aborting the current operation..."
            # gt doesn't have continue --abort, use git rebase --abort
            git rebase --abort
            exit $?
        else
            log "Resuming the paused operation..."
            gt continue "$@"
            result=$?
            if [ $result -eq 0 ]; then
                log "âœ“ Operation resumed successfully"
            else
                echo "Error: Failed to resume operation" >&2
            fi
            exit $result
        fi
        ;;
    "")
        echo "Error: No command specified" >&2
        usage
        exit 1
        ;;
    *)
        echo "Error: Unknown command: $COMMAND" >&2
        usage
        exit 1
        ;;
esac

