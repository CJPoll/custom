#!/bin/bash

set -euo pipefail

# Source the install_git_stack script
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [ -f "${SCRIPT_DIR}/../install_git_stack.sh" ]; then
    source "${SCRIPT_DIR}/../install_git_stack.sh"
fi

# Determine if we're in a worktree and find the actual project root
CURRENT_DIR="$(pwd)"
PROJECT_DIR="$CURRENT_DIR"

# Check if we're in a worktree by looking for .git file (not directory)
if [ -f "$CURRENT_DIR/.git" ]; then
    # We're in a worktree, extract the actual project path
    GIT_DIR=$(cat "$CURRENT_DIR/.git" | grep "gitdir:" | cut -d' ' -f2)
    # Git dir for worktree looks like: /path/to/project/.git/worktrees/branch-name
    # We need to go up 3 levels to get the project root
    PROJECT_DIR=$(dirname $(dirname $(dirname "$GIT_DIR")))
fi

# Extract just the project name from the path
PROJECT_NAME=$(basename "$PROJECT_DIR")
WORKTREES_DIR="${HOME}/.local/worktrees/$PROJECT_NAME"

QUIET=false
NO_SYMLINK=false
CHECK_DIR=""
PR_REVIEW=false
PARENT_BRANCH="main"
PARENT_BRANCH_EXPLICIT=false
SWITCH_AFTER_CREATE=false

usage() {
    cat << EOF
Usage: wt <command> [options]

Commands:
  init              Set up the worktrees directory
  list              List all worktrees for the current project
  create <branch>   Create a worktree for the specified branch
                    (symlinks .claude/ directory from main project if present)
  rm <branch>       Remove the worktree for the specified branch
  switch <branch>   Change to the worktree for the specified branch
                    (In tmux: switches/creates session. Outside tmux: shows cd command)
  merge <branch>    Merge a worktree branch (must be run from parent repo)
  is-worktree       Check if a directory is a git worktree
                    Exit codes: 0=worktree, 1=project root, 2=neither
  stack             Show branch hierarchy for all worktrees in the project
  stack --install   Install git-stack if not already installed
                    Downloads and installs git-stack from the official GitHub releases
  stack parent <branch>  Set or update the parent branch for the current branch
  sync [branch]     Sync the stack by rebasing child branches onto updated parents
  sync --continue   Continue a sync operation after resolving conflicts
  next              Navigate to a child branch in the stack (switch tmux session)
  prev              Navigate to the parent branch in the stack (switch tmux session)
  run <command>     Execute a command across all branches in the stack (in dependency order)
  push --stack      Push all ready branches in the stack to origin
  pr --stack        Create pull requests for all branches in the stack

Options:
  --quiet           Suppress output from script and subcommands
  --no-symlink      Do not create symlink to .claude directory (for create command)
  --switch          Switch to the worktree after creating it (for create command)
  --dir <directory> Check the specified directory (for is-worktree command, defaults to current dir)
  --pr-review       Open changed files in tabs for PR review (for switch command)
  --parent <branch> Parent branch for PR review or stack creation (defaults to main)
  --stack           Execute command for entire stack (for push/pr commands)
  --all             Push all ready branches, not just new ones (for push --stack)
  --dry-run         Show what would be done without actually doing it (for push/pr commands)
  --draft           Create draft pull requests (for pr --stack)

Examples:
  wt init
  wt list
  wt create feature/my-feature
  wt create feature/child --parent feature/parent
  wt create --no-symlink experimental/test
  wt create --switch feature/my-feature
  wt switch feature/my-feature
  wt switch feature/my-feature --pr-review
  wt switch feature/my-feature --pr-review --parent develop
  wt rm feature/my-feature
  wt merge feature/my-feature
  wt create --quiet bugfix/issue-123
  wt is-worktree
  wt is-worktree --dir /path/to/directory
  wt stack
  wt stack --install
  wt sync
  wt sync feature/child
  wt sync --continue
  wt next
  wt prev
  wt run "npm test"
  wt run "git status"
  wt push --stack --dry-run
  wt push --stack
  wt push --stack --all
  wt pr --stack --dry-run
  wt pr --stack
  wt pr --stack --draft
EOF
}

log() {
    if [ "$QUIET" = false ]; then
        echo "$@" >&2
    fi
}

run_cmd() {
    if [ "$QUIET" = true ]; then
        "$@" >/dev/null 2>&1
    else
        "$@"
    fi
}

init_worktrees() {
    log "Initializing worktrees directory..."
    
    if [ ! -d "$PROJECT_DIR/.git" ]; then
        echo "Error: Not in a git repository" >&2
        exit 1
    fi
    
    mkdir -p "$WORKTREES_DIR"
    
    log "Worktrees directory initialized at: $WORKTREES_DIR"
}

list_worktrees() {
    if [ ! -d "$WORKTREES_DIR" ]; then
        log "No worktrees directory found. Run 'wt init' first."
        return 0
    fi
    
    # Get list of directories in worktrees
    local worktrees=()
    if [ -d "$WORKTREES_DIR" ]; then
        while IFS= read -r -d '' dir; do
            worktrees+=("$(basename "$dir")")
        done < <(find "$WORKTREES_DIR" -mindepth 1 -maxdepth 1 -type d -print0 2>/dev/null)
    fi
    
    if [ ${#worktrees[@]} -eq 0 ]; then
        log "No worktrees found."
        return 0
    fi
    
    # Get current branch for comparison
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
    
    log "Worktrees for this project:"
    log ""
    
    # Use git worktree list to get more info
    local git_worktrees
    git_worktrees=$(git worktree list 2>/dev/null || echo "")
    
    for worktree in "${worktrees[@]}"; do
        local marker=""
        local worktree_path="$WORKTREES_DIR/$worktree"
        
        # Check if this is the current directory
        if [[ "$(pwd)" == "$worktree_path" ]]; then
            marker=" *"
        fi
        
        # Try to get the commit info from git worktree list
        local commit_info=""
        if [[ -n "$git_worktrees" ]]; then
            commit_info=$(echo "$git_worktrees" | grep "$worktree_path" | awk '{print $2, $3}' || echo "")
        fi
        
        if [[ -n "$commit_info" ]]; then
            echo "  $worktree$marker ($commit_info)"
        else
            echo "  $worktree$marker"
        fi
    done
}

create_worktree() {
    local branch="$1"
    local worktree_path="$WORKTREES_DIR/$branch"
    
    if [ -z "$branch" ]; then
        echo "Error: Branch name is required" >&2
        usage
        exit 1
    fi
    
    if [ ! -d "$WORKTREES_DIR" ]; then
        log "Worktrees directory not found. Running init first..."
        init_worktrees
    fi
    
    if [ -d "$worktree_path" ]; then
        echo "Error: Worktree already exists at: $worktree_path" >&2
        exit 1
    fi
    
    log "Creating worktree for branch: $branch"
    
    # Determine the base branch for the new worktree
    local base_branch="$PARENT_BRANCH"
    
    # Check if branch exists
    if git show-ref --verify --quiet "refs/heads/$branch"; then
        log "Checking out existing branch: $branch"
        run_cmd git worktree add "$worktree_path" "$branch"
    else
        # Check if it exists as a remote branch
        if git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
            log "Creating local branch from remote: origin/$branch"
            run_cmd git worktree add "$worktree_path" -b "$branch" "origin/$branch"
        else
            # Create new branch from the parent branch
            if [ "$base_branch" != "main" ] && [ "$base_branch" != "master" ]; then
                log "Creating new branch: $branch from parent: $base_branch"
                # Ensure parent branch exists
                if git show-ref --verify --quiet "refs/heads/$base_branch"; then
                    run_cmd git worktree add "$worktree_path" -b "$branch" "$base_branch"
                else
                    echo "Error: Parent branch '$base_branch' does not exist" >&2
                    exit 1
                fi
            else
                log "Creating new branch: $branch"
                run_cmd git worktree add "$worktree_path" -b "$branch"
            fi
        fi
    fi
    
    log "Worktree created at: $worktree_path"
    
    # Configure git-stack parent relationship if parent was explicitly specified
    # Note: We check if PARENT_BRANCH was changed from its default value (main)
    # by checking if it matches the default or if --parent flag was used
    if [ "$PARENT_BRANCH" != "main" ] || [[ "${PARENT_BRANCH_EXPLICIT:-false}" == "true" ]]; then
        log "Configuring git-stack parent relationship: $branch -> $PARENT_BRANCH"
        git -C "$worktree_path" config --add git-stack.auto-base "$PARENT_BRANCH"
        git -C "$worktree_path" config --add "branch.$branch.stack-base" "$PARENT_BRANCH"
    fi
    
    # Create symlink to .claude directory if it exists in the main project (unless --no-symlink is set)
    if [ "$NO_SYMLINK" = false ] && [ -d "$PROJECT_DIR/.claude" ]; then
        if [ ! -e "$worktree_path/.claude" ]; then
            ln -s "$PROJECT_DIR/.claude" "$worktree_path/.claude"
            log "Created symlink to .claude directory"
        else
            log "Warning: .claude already exists in worktree, skipping symlink"
        fi
    fi
}

remove_worktree() {
    local branch="$1"
    local worktree_path="$WORKTREES_DIR/$branch"
    
    if [ -z "$branch" ]; then
        echo "Error: Branch name is required" >&2
        usage
        exit 1
    fi
    
    if [ ! -d "$worktree_path" ]; then
        echo "Error: Worktree not found at: $worktree_path" >&2
        exit 1
    fi
    
    log "Removing worktree for branch: $branch"
    
    # Get the project name from the current directory
    local project_name=$(basename "$PROJECT_DIR")
    
    # Create session name with worktree info (same format as in switch_worktree)
    # Replace slashes in branch name with dashes to avoid tmux issues
    local safe_branch=$(echo "$branch" | tr '/' '-')
    local session_name="${project_name}-wt-${safe_branch}"
    
    # Check if tmux session exists and kill it
    if tmux has-session -t "$session_name" 2>/dev/null; then
        log "Killing tmux session: $session_name"
        run_cmd tmux kill-session -t "$session_name"
    fi
    
    # Remove the worktree
    run_cmd git worktree remove "$worktree_path" --force
    
    # Clean up any remaining directory if it exists
    if [ -d "$worktree_path" ]; then
        rm -rf "$worktree_path"
    fi
    
    # Prune worktree metadata
    run_cmd git worktree prune
    
    log "Worktree removed: $branch"
}

switch_worktree() {
    local branch="$1"
    local worktree_path="$WORKTREES_DIR/$branch"
    
    if [ -z "$branch" ]; then
        echo "Error: Branch name is required" >&2
        usage
        return 1
    fi
    
    # Special handling for main/master branch - use project root
    if [ "$branch" = "main" ] || [ "$branch" = "master" ]; then
        worktree_path="$PROJECT_DIR"
        # Check if the branch matches what's actually in the project root
        local project_branch=$(git -C "$PROJECT_DIR" rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [ "$project_branch" != "$branch" ]; then
            echo "Error: Project root is on branch '$project_branch', not '$branch'" >&2
            return 1
        fi
    elif [ ! -d "$worktree_path" ]; then
        echo "Error: Worktree not found at: $worktree_path" >&2
        echo "Available worktrees:" >&2
        if [ -d "$WORKTREES_DIR" ]; then
            ls -1 "$WORKTREES_DIR" 2>/dev/null | sed 's/^/  /' >&2
        fi
        return 1
    fi
    
    log "Switching to worktree: $branch"
    
    # Get the project name from the current directory
    local project_name=$(basename "$PROJECT_DIR")
    
    # Create session name
    if [ "$branch" = "main" ] || [ "$branch" = "master" ]; then
        # Main branch uses just the project name
        local session_name="$project_name"
    else
        # Worktrees use project-wt-branch format
        # Replace slashes in branch name with dashes to avoid tmux issues
        local safe_branch=$(echo "$branch" | tr '/' '-')
        local session_name="${project_name}-wt-${safe_branch}"
    fi
    
    # Check if we're in a tmux session
    if [ -n "${TMUX:-}" ]; then
        # We're in tmux, use proj to switch/create sessions
        # Call proj directly, with optional --pr-review flag
        if [ "$PR_REVIEW" = true ]; then
            # For stack-aware PR review, detect the actual parent branch
            local review_base_branch="$PARENT_BRANCH"
            if [ "$PARENT_BRANCH" = "main" ] || [ "$PARENT_BRANCH" = "master" ]; then
                # If using default, try to detect the actual parent from git config
                local detected_parent=$(get_branch_parent "$branch")
                if [ -n "$detected_parent" ]; then
                    review_base_branch="$detected_parent"
                    log "Using detected parent branch for PR review: $review_base_branch"
                fi
            fi
            proj "$session_name" --path "$worktree_path" --pr-review --base-branch "$review_base_branch"
        else
            proj "$session_name" --path "$worktree_path"
        fi
    else
        # Not in tmux, output the cd command for the user to execute
        # Since we can't change the parent shell's directory from a script
        if [ "$QUIET" = true ]; then
            # In quiet mode, just output the path
            echo "$worktree_path"
        else
            log "Not in tmux session. To switch to the worktree, run:"
            log ""
            echo "cd $worktree_path"
        fi
    fi
}

merge_worktree() {
    local branch="$1"
    local worktree_path="$WORKTREES_DIR/$branch"
    
    if [ -z "$branch" ]; then
        echo "Error: Branch name is required" >&2
        usage
        return 1
    fi
    
    # Check if we're in the parent worktree (not a worktree)
    # Run is_worktree in a subshell to capture exit code
    local is_wt_result
    # Run in a subshell to prevent exit from terminating our script
    # Temporarily disable set -e for this check
    set +e
    (
        CHECK_DIR="$(pwd)"
        is_worktree
    )
    is_wt_result=$?
    set -e
    
    if [ $is_wt_result -eq 0 ]; then
        echo "Error: wt merge must be run from the parent repository, not a worktree" >&2
        return 1
    elif [ $is_wt_result -eq 2 ]; then
        echo "Error: Not in a git repository" >&2
        return 1
    fi
    # is_wt_result == 1 means we're in the project root, which is what we want
    
    # Check if worktree exists
    if [ ! -d "$worktree_path" ]; then
        echo "Error: No worktree found for branch: $branch" >&2
        echo "Available worktrees:" >&2
        if [ -d "$WORKTREES_DIR" ]; then
            ls -1 "$WORKTREES_DIR" 2>/dev/null | sed 's/^/  /' >&2
        fi
        return 2
    fi
    
    log "Merging branch: $branch"
    
    # Get the merge base
    local merge_base=$(git merge-base HEAD "$branch" 2>/dev/null)
    if [ -z "$merge_base" ]; then
        echo "Error: Could not find merge base for branch: $branch" >&2
        return 1
    fi
    
    # Check if fast-forward is possible
    if ! git merge-base --is-ancestor HEAD "$branch" 2>/dev/null; then
        echo "Error: Cannot fast-forward merge. The branch has diverged." >&2
        return 1
    fi
    
    # Get the diff for the merge
    local diff_output=$(git diff "$merge_base".."$branch" 2>/dev/null)
    
    if [ -z "$diff_output" ]; then
        echo "No changes to merge from branch: $branch"
        return 0
    fi
    
    # Generate commit message using Claude
    log "Generating merge commit message..."
    local commit_message=$(echo "$diff_output" | claude -p "Generate a concise merge commit message based on this diff. The message should summarize what changes are being merged. Format: 'Merge <other-branch> -> <current-branch>: <summary of changes>'. Keep it under 72 characters for the first line, and add details below if needed. Give no additional output beyond the commit message. Format according to 'conventional commits' style, providing all information in teh 'conventional commit' specification which is currently avaialable. Include credit to Claude Code as co-author. Do not surround the commit message with quotes, backticks, or other symbols." 2>/dev/null)
    
    if [ -z "$commit_message" ]; then
        # Fallback message if Claude fails
        commit_message="Merge $branch"
    fi
    
    # Perform the merge with squash
    log "Performing merge..."
    if git merge --ff-only --squash "$branch" 2>&1; then
        # Commit with the generated message
        if git commit -m "$commit_message" 2>&1; then
            log "Merge completed successfully"
            
            # Get the current branch (where we merged into)
            local current_branch=$(git rev-parse --abbrev-ref HEAD)
            
            # Rebase any child branches onto the current branch
            rebase_children_after_merge "$branch" "$current_branch"
            
            # Remove the worktree
            log "Removing merged worktree..."
            remove_worktree "$branch"
        else
            echo "Error: Failed to commit merge" >&2
            # Reset the merge
            git merge --abort 2>/dev/null || git reset --hard HEAD 2>/dev/null
            return 1
        fi
    else
        echo "Error: Merge failed" >&2
        return 1
    fi
}

is_worktree() {
    local dir="${CHECK_DIR:-$(pwd)}"
    
    # Get the absolute path
    dir="$(realpath "$dir" 2>/dev/null)" || exit 2
    
    # Check if directory is an immediate child of any DEVPATH directory
    if [[ -n "$DEVPATH" ]]; then
        # Split DEVPATH by colon
        IFS=':' read -ra DEV_DIRS <<< "$DEVPATH"
        for dev_dir in "${DEV_DIRS[@]}"; do
            # Expand the dev_dir path (handle ~ and variables)
            dev_dir="$(eval echo "$dev_dir")"
            dev_dir="$(realpath "$dev_dir" 2>/dev/null)" || continue
            
            # Check if dir is an immediate child of this dev_dir
            local parent_dir="$(dirname "$dir")"
            if [[ "$parent_dir" == "$dev_dir" ]]; then
                # This is a project root directory, not a worktree
                exit 1
            fi
        done
    fi
    
    # Find the git directory by traversing up from the target directory
    local git_dir="$dir"
    while [[ "$git_dir" != "/" ]]; do
        if [[ -d "$git_dir/.git" ]] || [[ -f "$git_dir/.git" ]]; then
            # Check if git worktree list contains this directory
            if git -C "$git_dir" worktree list 2>/dev/null | grep -q "^$dir\s"; then
                exit 0
            else
                exit 2
            fi
        fi
        git_dir="$(dirname "$git_dir")"
    done
    
    # Not in a git repository
    exit 2
}

set_stack_parent() {
    local parent_branch="$1"
    
    if [ -z "$parent_branch" ]; then
        echo "Error: Parent branch name is required" >&2
        echo "Usage: wt stack parent <parent-branch>" >&2
        return 1
    fi
    
    # Get current branch
    local current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    if [ -z "$current_branch" ]; then
        echo "Error: Not in a git repository" >&2
        return 1
    fi
    
    # Check if parent branch exists
    if ! git show-ref --verify --quiet "refs/heads/$parent_branch" && \
       ! git show-ref --verify --quiet "refs/remotes/origin/$parent_branch"; then
        echo "Error: Parent branch '$parent_branch' does not exist locally or on origin" >&2
        return 1
    fi
    
    # Don't allow setting a branch as its own parent
    if [ "$current_branch" = "$parent_branch" ]; then
        echo "Error: Cannot set a branch as its own parent" >&2
        return 1
    fi
    
    log "Setting parent of '$current_branch' to '$parent_branch'"
    
    # Set the git config for stack parent
    git config --add git-stack.auto-base "$parent_branch"
    git config --add "branch.$current_branch.stack-base" "$parent_branch"
    
    log "âœ“ Parent relationship configured: $current_branch -> $parent_branch"
    
    # Show the updated stack structure
    log ""
    log "Updated stack structure:"
    show_worktree_stack
}

show_worktree_stack() {
    # Check if the --install flag is present
    # This flag triggers automatic installation of git-stack from GitHub releases
    # if it's not already installed on the system
    if [ "${INSTALL_GIT_STACK:-false}" = true ]; then
        install_git_stack
        exit 0
    fi

    # Check if git-stack is available
    if ! command -v git-stack /dev/null; then
        echo "Error: git-stack not found. Install from https://github.com/gitext-rs/git-stack" 2
        return 1
    fi
    
    # Check if we're in a git repository
    if ! git rev-parse --git-dir &>/dev/null; then
        echo "Error: Not in a git repository" >&2
        return 1
    fi
    
    # Build branch->worktree mapping
    declare -A branch_to_worktree
    declare -A worktree_to_current
    declare -A branch_has_children
    
    # Get current directory for comparison
    local current_dir="$(pwd)"
    
    # Add main project directory
    local main_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    if [ -n "$main_branch" ]; then
        branch_to_worktree["$main_branch"]="$PROJECT_DIR"
        if [[ "$current_dir" == "$PROJECT_DIR" ]]; then
            worktree_to_current["$PROJECT_DIR"]="*"
        fi
    fi
    
    # Add worktrees
    if [ -d "$WORKTREES_DIR" ]; then
        for wt in "$WORKTREES_DIR"/*; do
            [ -d "$wt" ] || continue
            local branch=$(git -C "$wt" rev-parse --abbrev-ref HEAD 2>/dev/null)
            if [ -n "$branch" ]; then
                branch_to_worktree["$branch"]="$wt"
                if [[ "$current_dir" == "$wt" ]]; then
                    worktree_to_current["$wt"]="*"
                fi
            fi
        done
    fi
    
    # Find which branches have children
    for branch in "${!branch_to_worktree[@]}"; do
        local children=($(get_branch_children "$branch"))
        if [ ${#children[@]} -gt 0 ]; then
            branch_has_children["$branch"]=1
        fi
    done
    
    log "Branch hierarchy for project: $(basename "$PROJECT_DIR")"
    log ""
    
    # Track stack structure
    local current_stack_parent=""
    local indent_next=false
    
    git stack 2>&1 | while IFS= read -r line; do
        # Skip empty lines
        if [[ -z "$line" ]]; then
            echo "$line"
            continue
        fi
        
        # Determine if we need to indent based on parent-child relationships
        local output_line="$line"
        local line_has_worktree=false
        local found_branch=""
        
        # Check if this line contains a worktree branch
        for branch in "${!branch_to_worktree[@]}"; do
            if [[ "$line" =~ (^|[[:space:],â”‚â”œâ””â”€âŒ½])${branch}([[:space:],\[]|\[|$) ]]; then
                line_has_worktree=true
                found_branch="$branch"
                break
            fi
        done
        
        # Apply indentation if this is a child of a worktree
        if [ "$indent_next" = true ] && [[ "$line" =~ ^âŒ½ ]]; then
            # Add indentation for children of worktrees
            output_line="  $line"
        fi
        
        # Update indentation flag based on whether this branch has children
        if [ "$line_has_worktree" = true ] && [ ${branch_has_children[$found_branch]+isset} ]; then
            indent_next=true
        elif [ "$line_has_worktree" = true ]; then
            indent_next=false
        fi
        
        # Reset indentation on non-branch lines or stack boundaries
        if [[ ! "$line" =~ ^âŒ½ ]] && [[ ! "$line" =~ ^[[:space:]]+âŒ½ ]]; then
            indent_next=false
        fi
        
        # Add annotations to branch names
        local modified_line="$output_line"
        
        # Process branches in order of length (longest first)
        local sorted_branches=()
        while IFS= read -r branch; do
            sorted_branches+=("$branch")
        done < <(printf '%s\n' "${!branch_to_worktree[@]}" | awk '{ print length, $0 }' | sort -nr | cut -d' ' -f2-)
        
        for branch in "${sorted_branches[@]}"; do
            local wt_path="${branch_to_worktree[$branch]}"
            local annotation=""
            local marker=""
            
            if [ ${worktree_to_current[$wt_path]+isset} ]; then
                marker="*"
            fi
            
            # Add green background with black text to annotations
            local green_bg_black_text="\033[42;30m"
            local green_fg=$'\033[32;49m\ue0b0\033[0m'  # Green arrow with default background
            local reset="\033[0m"
            
            if [[ "$wt_path" == "$PROJECT_DIR" ]]; then
                if [ -n "$marker" ]; then
                    annotation="${green_bg_black_text} [main*] ${green_fg}"
                else
                    annotation="${green_bg_black_text} [main] ${green_fg}"
                fi
            else
                if [ -n "$marker" ]; then
                    annotation="${green_bg_black_text} [wt*] ${green_fg}"
                else
                    annotation="${green_bg_black_text} [wt] ${green_fg}"
                fi
            fi
            
            # Check if branch appears in the line with proper boundaries
            if [[ "$modified_line" =~ (^|[[:space:],â”‚â”œâ””â”€âŒ½])${branch}([[:space:],\[]|\[|$) ]]; then
                # Only replace the first occurrence to avoid double-annotation
                # Add tmux cyan (colour39) background with black text to branch name
                local cyan_bg_black_text="\033[48;5;39;30m"
                local reset="\033[0m"
                # Arrow before branch: default foreground with tmux cyan background
                local pre_arrow=$'\033[38;5;15;48;5;39m\ue0b0'
                # Powerline arrow with tmux cyan foreground and green background for transition
                local arrow=$'\033[38;5;39;42m\ue0b0'
                modified_line="${modified_line/${branch}/${pre_arrow}${cyan_bg_black_text} ${branch} ${arrow}${annotation}}"
            fi
        done
        
        echo -e "$modified_line"
    done
}

sync_worktree_stack() {
    local start_branch="${1:-}"
    local continue_sync=false
    
    # Check for --continue flag
    if [ "$start_branch" = "--continue" ]; then
        continue_sync=true
        start_branch=""
    fi
    
    # Handle continue mode
    if [ "$continue_sync" = true ]; then
        sync_worktree_continue
        return $?
    fi
    
    # Get current branch if not specified
    if [ -z "$start_branch" ]; then
        start_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [ -z "$start_branch" ]; then
            echo "Error: Not in a git repository" >&2
            return 1
        fi
    fi
    
    log "Syncing stack containing branch: $start_branch"
    
    # First, fetch latest changes from origin
    log "Fetching latest changes from origin..."
    git fetch origin
    
    # Get all branches in the stack
    local branches=($(get_stack_branches "$start_branch"))
    if [ ${#branches[@]} -eq 0 ]; then
        echo "Error: No branches found in stack" >&2
        return 1
    fi
    
    log "Found ${#branches[@]} branches in stack: ${branches[*]}"
    log ""
    
    local failed_branch=""
    local rebased_count=0
    
    # Process each branch in order (parent to child)
    for branch in "${branches[@]}"; do
        local worktree_path=""
        
        # Determine worktree path
        if [ "$branch" = "main" ] || [ "$branch" = "master" ]; then
            worktree_path="$PROJECT_DIR"
        else
            worktree_path="$WORKTREES_DIR/$branch"
        fi
        
        if [ ! -d "$worktree_path" ]; then
            log "âš ï¸  Skipping $branch - worktree not found"
            continue
        fi
        
        # Check if this branch has an in-progress rebase
        if [ -d "$worktree_path/.git/rebase-merge" ] || [ -d "$worktree_path/.git/rebase-apply" ]; then
            log "âš ï¸  $branch has an in-progress rebase. Resolve conflicts and run 'wt sync --continue'"
            failed_branch="$branch"
            break
        fi
        
        # Get parent branch
        local parent=$(get_branch_parent "$branch")
        if [ -z "$parent" ] || [ "$parent" = "$branch" ]; then
            log "âœ“ $branch - no parent branch, skipping"
            continue
        fi
        
        # Check if branch needs rebasing onto parent
        local needs_rebase=false
        local merge_base=$(git -C "$worktree_path" merge-base "$branch" "$parent" 2>/dev/null)
        local parent_tip=$(git -C "$worktree_path" rev-parse "$parent" 2>/dev/null)
        
        if [ "$merge_base" != "$parent_tip" ]; then
            needs_rebase=true
        fi
        
        if [ "$needs_rebase" = true ]; then
            log "ðŸ”„ Rebasing $branch onto $parent..."
            
            # Save current directory
            local original_dir=$(pwd)
            
            # Switch to worktree and perform rebase
            cd "$worktree_path"
            
            if git rebase "$parent"; then
                log "âœ“ Successfully rebased $branch"
                ((rebased_count++))
            else
                log ""
                log "âš ï¸  Conflict detected while rebasing $branch"
                log "ðŸ“ Worktree location: $worktree_path"
                log ""
                log "To resolve:"
                log "  1. cd $worktree_path"
                log "  2. Fix conflicts and stage changes"
                log "  3. git rebase --continue"
                log "  4. wt sync --continue"
                log ""
                failed_branch="$branch"
                
                # Show conflict status
                git status --short
                
                cd "$original_dir"
                break
            fi
            
            cd "$original_dir"
        else
            log "âœ“ $branch - already up to date with $parent"
        fi
    done
    
    log ""
    
    if [ -n "$failed_branch" ]; then
        return 1
    elif [ $rebased_count -eq 0 ]; then
        log "All branches are already up to date"
    else
        log "Successfully rebased $rebased_count branch(es)"
    fi
    
    # Optionally run git-stack sync for any additional git-stack specific operations
    if command -v git-stack &>/dev/null; then
        log ""
        log "Running git-stack sync for additional updates..."
        git stack sync
    fi
}

sync_worktree_continue() {
    log "Continuing sync operation..."
    log ""
    
    # Find all worktrees with in-progress rebases
    local found_rebase=false
    local completed_rebases=0
    
    # Check main project
    if [ -d "$PROJECT_DIR/.git/rebase-merge" ] || [ -d "$PROJECT_DIR/.git/rebase-apply" ]; then
        local branch=$(git -C "$PROJECT_DIR" rev-parse --abbrev-ref HEAD 2>/dev/null)
        log "Found in-progress rebase in main project (branch: $branch)"
        log "Please complete the rebase manually in: $PROJECT_DIR"
        found_rebase=true
    fi
    
    # Check all worktrees
    if [ -d "$WORKTREES_DIR" ]; then
        for wt in "$WORKTREES_DIR"/*; do
            [ -d "$wt" ] || continue
            
            if [ -d "$wt/.git/rebase-merge" ] || [ -d "$wt/.git/rebase-apply" ]; then
                local branch=$(basename "$wt")
                found_rebase=true
                
                log "Checking rebase status for $branch..."
                
                # Check if there are still conflicts
                if git -C "$wt" status --porcelain | grep -q "^UU\|^AA\|^DD"; then
                    log "âš ï¸  $branch still has unresolved conflicts"
                    log "    Location: $wt"
                    return 1
                else
                    # Try to continue the rebase
                    log "Attempting to continue rebase for $branch..."
                    if git -C "$wt" rebase --continue 2>&1; then
                        log "âœ“ Successfully continued rebase for $branch"
                        ((completed_rebases++))
                    else
                        log "âš ï¸  Failed to continue rebase for $branch"
                        log "    Please resolve manually in: $wt"
                        return 1
                    fi
                fi
            fi
        done
    fi
    
    if [ "$found_rebase" = false ]; then
        log "No in-progress rebases found."
        log ""
        log "Resuming normal sync..."
        log ""
        # Resume normal sync from current directory
        sync_worktree_stack
    else
        if [ $completed_rebases -gt 0 ]; then
            log ""
            log "Completed $completed_rebases rebase(s)."
            log "Resuming sync for remaining branches..."
            log ""
            # Resume sync
            sync_worktree_stack
        fi
    fi
}

get_branch_parent() {
    local branch="$1"
    local worktree_path=""
    
    # Find the worktree path for this branch
    if [ -n "$branch" ]; then
        # Check if it's a worktree branch
        if [ -d "$WORKTREES_DIR/$branch" ]; then
            worktree_path="$WORKTREES_DIR/$branch"
        else
            # Check if we're in the main project and this is the current branch
            local current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
            if [ "$branch" = "$current_branch" ] && [ -d "$PROJECT_DIR/.git" ]; then
                worktree_path="$PROJECT_DIR"
            fi
        fi
    fi
    
    if [ -z "$worktree_path" ]; then
        return 1
    fi
    
    # Get the parent branch from git config
    local parent=$(git -C "$worktree_path" config --get "branch.$branch.stack-base" 2>/dev/null)
    if [ -z "$parent" ]; then
        parent=$(git -C "$worktree_path" config --get "git-stack.auto-base" 2>/dev/null)
    fi
    
    echo "$parent"
}

get_branch_children() {
    local branch="$1"
    local children=()
    
    # Check main project
    local main_branch=$(git -C "$PROJECT_DIR" rev-parse --abbrev-ref HEAD 2>/dev/null)
    if [ -n "$main_branch" ]; then
        local main_parent=$(get_branch_parent "$main_branch")
        if [ "$main_parent" = "$branch" ]; then
            children+=("$main_branch")
        fi
    fi
    
    # Check all worktrees
    if [ -d "$WORKTREES_DIR" ]; then
        for wt in "$WORKTREES_DIR"/*; do
            [ -d "$wt" ] || continue
            local wt_branch=$(git -C "$wt" rev-parse --abbrev-ref HEAD 2>/dev/null)
            if [ -n "$wt_branch" ]; then
                local wt_parent=$(get_branch_parent "$wt_branch")
                if [ "$wt_parent" = "$branch" ]; then
                    children+=("$wt_branch")
                fi
            fi
        done
    fi
    
    # Output children one per line
    for child in "${children[@]}"; do
        echo "$child"
    done
}

navigate_stack() {
    local direction="$1"
    local current_branch=""
    local target_branch=""
    
    # Get current branch
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    if [ -z "$current_branch" ]; then
        echo "Error: Not in a git repository" >&2
        return 1
    fi
    
    case "$direction" in
        next)
            # Get children of current branch
            local children=($(get_branch_children "$current_branch"))
            if [ ${#children[@]} -eq 0 ]; then
                echo "No child branches found for: $current_branch" >&2
                return 1
            elif [ ${#children[@]} -eq 1 ]; then
                target_branch="${children[0]}"
            else
                # Multiple children, show options
                echo "Multiple child branches found:" >&2
                local i=1
                for child in "${children[@]}"; do
                    echo "  $i) $child" >&2
                    ((i++))
                done
                echo -n "Select branch (1-${#children[@]}): " >&2
                read -r selection
                if [[ "$selection" =~ ^[0-9]+$ ]] && [ "$selection" -ge 1 ] && [ "$selection" -le ${#children[@]} ]; then
                    target_branch="${children[$((selection-1))]}"
                else
                    echo "Invalid selection" >&2
                    return 1
                fi
            fi
            ;;
        prev)
            # Get parent of current branch
            target_branch=$(get_branch_parent "$current_branch")
            if [ -z "$target_branch" ]; then
                echo "No parent branch found for: $current_branch" >&2
                return 1
            fi
            ;;
        *)
            echo "Error: Invalid direction: $direction" >&2
            return 1
            ;;
    esac
    
    # Switch to the target branch
    if [ -n "$target_branch" ]; then
        log "Navigating from $current_branch to $target_branch"
        switch_worktree "$target_branch"
    fi
}

get_stack_branches() {
    local start_branch="${1:-}"
    local branches=()
    local visited=()
    
    # If no start branch specified, get current branch
    if [ -z "$start_branch" ]; then
        start_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [ -z "$start_branch" ]; then
            echo "Error: Not in a git repository" >&2
            return 1
        fi
    fi
    
    # Collect branches by following parent links up from start branch
    local current_branch="$start_branch"
    local stack_branches=()
    
    # Add the starting branch
    stack_branches+=("$current_branch")
    
    # Follow parent links up to the root
    while true; do
        local parent=$(get_branch_parent "$current_branch")
        if [ -z "$parent" ] || [ "$parent" = "$current_branch" ]; then
            # No parent or self-parent means we've reached the root
            break
        fi
        
        # Check if we've seen this branch before (cycle detection)
        for b in "${visited[@]}"; do
            if [ "$b" = "$parent" ]; then
                echo "Error: Cycle detected in branch stack" >&2
                return 1
            fi
        done
        
        visited+=("$current_branch")
        stack_branches+=("$parent")
        current_branch="$parent"
    done
    
    # Reverse the array to get root-to-leaf order
    local reversed_branches=()
    for ((i=${#stack_branches[@]}-1; i>=0; i--)); do
        reversed_branches+=("${stack_branches[$i]}")
    done
    
    # Also include any children of the start branch (to handle the full stack)
    local queue=("$start_branch")
    local processed=("$start_branch")
    
    while [ ${#queue[@]} -gt 0 ]; do
        local current="${queue[0]}"
        queue=("${queue[@]:1}")  # Remove first element
        
        # Get children of current branch
        local children=($(get_branch_children "$current"))
        for child in "${children[@]}"; do
            # Skip if already in our list
            local skip=false
            for b in "${reversed_branches[@]}"; do
                if [ "$b" = "$child" ]; then
                    skip=true
                    break
                fi
            done
            
            if [ "$skip" = false ]; then
                reversed_branches+=("$child")
                queue+=("$child")
            fi
        done
    done
    
    # Output branches
    for branch in "${reversed_branches[@]}"; do
        echo "$branch"
    done
}

run_in_worktree() {
    local branch="$1"
    local command="$2"
    local worktree_path=""
    
    # Determine worktree path
    if [ "$branch" = "main" ] || [ "$branch" = "master" ]; then
        worktree_path="$PROJECT_DIR"
    else
        worktree_path="$WORKTREES_DIR/$branch"
    fi
    
    if [ ! -d "$worktree_path" ]; then
        echo "Error: Directory not found for branch $branch: $worktree_path" >&2
        return 1
    fi
    
    # Run command in the worktree directory
    log "Running in $branch: $command"
    (cd "$worktree_path" && eval "$command")
    local result=$?
    
    if [ $result -eq 0 ]; then
        log "âœ“ Success in $branch"
    else
        log "âœ— Failed in $branch (exit code: $result)"
    fi
    
    return $result
}

run_across_stack() {
    local command="$1"
    
    if [ -z "$command" ]; then
        echo "Error: Command is required" >&2
        usage
        return 1
    fi
    
    # Get all branches in the stack
    local branches=($(get_stack_branches))
    if [ ${#branches[@]} -eq 0 ]; then
        echo "Error: No branches found in stack" >&2
        return 1
    fi
    
    log "Running command across stack: $command"
    log "Branches in order: ${branches[*]}"
    log ""
    
    local failed_branch=""
    
    # Run command in each worktree
    for branch in "${branches[@]}"; do
        if ! run_in_worktree "$branch" "$command"; then
            failed_branch="$branch"
            break
        fi
        log ""
    done
    
    if [ -n "$failed_branch" ]; then
        echo ""
        echo "Error: Command failed in branch: $failed_branch" >&2
        # Find remaining branches after the failed one
        local remaining=()
        local found_failed=false
        for b in "${branches[@]}"; do
            if [ "$found_failed" = true ]; then
                remaining+=("$b")
            elif [ "$b" = "$failed_branch" ]; then
                found_failed=true
            fi
        done
        if [ ${#remaining[@]} -gt 0 ]; then
            echo "Skipped branches: ${remaining[*]}" >&2
        fi
        return 1
    else
        log ""
        log "Command completed successfully across all branches"
    fi
}

rebase_children_after_merge() {
    local merged_branch="$1"
    local new_base_branch="$2"
    
    # Find all children of the merged branch
    local children=($(get_branch_children "$merged_branch"))
    
    if [ ${#children[@]} -eq 0 ]; then
        log "No child branches found for $merged_branch"
        return 0
    fi
    
    log ""
    log "Found ${#children[@]} child branch(es) that need rebasing:"
    for child in "${children[@]}"; do
        log "  - $child"
    done
    log ""
    
    local failed_rebase=""
    
    for child in "${children[@]}"; do
        local child_worktree="$WORKTREES_DIR/$child"
        
        if [ ! -d "$child_worktree" ]; then
            log "âœ— Skipping $child - worktree not found"
            continue
        fi
        
        log "Rebasing $child onto $new_base_branch..."
        
        # Save current branch to return to it later
        local current_branch=$(git rev-parse --abbrev-ref HEAD)
        
        # Switch to child worktree and rebase
        if cd "$child_worktree" && git rebase --onto "$new_base_branch" "$merged_branch" "$child" 2>&1; then
            log "âœ“ Successfully rebased $child"
            
            # Update the parent branch configuration
            git config "branch.$child.stack-base" "$new_base_branch"
            log "âœ“ Updated parent configuration for $child"
        else
            log "âœ— Failed to rebase $child"
            log "  You'll need to manually rebase this branch:"
            log "  cd $child_worktree && git rebase --onto $new_base_branch $merged_branch $child"
            failed_rebase="$child"
            
            # Abort the failed rebase
            git rebase --abort 2>/dev/null || true
        fi
        
        # Return to original directory
        cd - >/dev/null
    done
    
    if [ -n "$failed_rebase" ]; then
        echo ""
        echo "Warning: Some child branches could not be automatically rebased" >&2
        echo "Please resolve conflicts manually" >&2
        return 1
    else
        log ""
        log "All child branches successfully rebased onto $new_base_branch"
        return 0
    fi
}

create_stack_prs() {
    local dry_run=false
    local draft=false
    
    # Parse PR options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                dry_run=true
                shift
                ;;
            --draft)
                draft=true
                shift
                ;;
            *)
                echo "Error: Unknown option for pr: $1" >&2
                return 1
                ;;
        esac
    done
    
    # Check if gh CLI is available
    if ! command -v gh &>/dev/null; then
        echo "Error: GitHub CLI (gh) is required for PR creation" >&2
        echo "Install from: https://cli.github.com/" >&2
        return 1
    fi
    
    # Get all branches in the stack
    local branches=($(get_stack_branches))
    if [ ${#branches[@]} -eq 0 ]; then
        echo "Error: No branches found in stack" >&2
        return 1
    fi
    
    log "Checking branches in stack for PR creation..."
    log ""
    
    local prs_to_create=()
    local all_ready=true
    
    # Check each branch
    for branch in "${branches[@]}"; do
        local worktree_path=""
        if [ "$branch" = "main" ] || [ "$branch" = "master" ]; then
            log "âš  $branch - skipping default branch"
            continue
        else
            worktree_path="$WORKTREES_DIR/$branch"
        fi
        
        if [ ! -d "$worktree_path" ]; then
            log "âœ— $branch - worktree not found"
            all_ready=false
            continue
        fi
        
        # Check if PR already exists
        local existing_pr=$(gh pr list --head "$branch" --json number --jq '.[0].number' 2>/dev/null)
        if [ -n "$existing_pr" ]; then
            log "âœ“ $branch - PR already exists (#$existing_pr)"
            continue
        fi
        
        # Check if branch has been pushed
        if ! git -C "$worktree_path" ls-remote --exit-code --heads origin "$branch" &>/dev/null; then
            log "âœ— $branch - not pushed to remote (use 'wt push --stack' first)"
            all_ready=false
            continue
        fi
        
        # Check for uncommitted changes
        if ! git -C "$worktree_path" diff-index --quiet HEAD -- 2>/dev/null; then
            log "âœ— $branch - has uncommitted changes"
            all_ready=false
            continue
        fi
        
        # Branch is ready for PR
        prs_to_create+=("$branch")
        log "âœ“ $branch - ready for PR creation"
    done
    
    if [ ${#prs_to_create[@]} -eq 0 ]; then
        log ""
        log "No PRs need to be created"
        return 0
    fi
    
    if [ "$all_ready" = false ]; then
        log ""
        log "Some branches have issues. Fix them before creating PRs."
        return 1
    fi
    
    log ""
    log "Will create PRs for: ${prs_to_create[*]}"
    
    if [ "$dry_run" = true ]; then
        log ""
        log "Dry run - no PRs were created"
        return 0
    fi
    
    log ""
    log "Creating PRs..."
    log ""
    
    # Create PRs in order
    local failed_pr=""
    for branch in "${prs_to_create[@]}"; do
        local worktree_path="$WORKTREES_DIR/$branch"
        
        # Determine the base branch (parent)
        local base_branch=$(get_branch_parent "$branch")
        if [ -z "$base_branch" ]; then
            base_branch="main"  # Default to main if no parent
        fi
        
        log "Creating PR for $branch (base: $base_branch)..."
        
        # Generate PR title and body
        local pr_title="$branch"
        local pr_body=""
        
        # Get the branch description from commits
        local branch_commits=$(git -C "$worktree_path" log --oneline "$base_branch..$branch" 2>/dev/null)
        local commit_count=$(echo "$branch_commits" | wc -l)
        
        pr_body="## Summary\n\n"
        
        # Add stack context if part of a stack
        local stack_children=($(get_branch_children "$branch"))
        if [ ${#stack_children[@]} -gt 0 ]; then
            pr_body="${pr_body}**This PR is part of a stack:**\n"
            pr_body="${pr_body}- Base: \`$base_branch\`\n"
            pr_body="${pr_body}- This: \`$branch\`\n"
            pr_body="${pr_body}- Children: "
            for child in "${stack_children[@]}"; do
                pr_body="${pr_body}\`$child\` "
            done
            pr_body="${pr_body}\n\n"
        fi
        
        pr_body="${pr_body}### Commits ($commit_count):\n\`\`\`\n$branch_commits\n\`\`\`\n\n"
        pr_body="${pr_body}## Test Plan\n\n[Describe testing approach]\n\n"
        pr_body="${pr_body}---\n*Created with \`wt pr --stack\`*"
        
        # Create the PR
        local pr_flags=""
        [ "$draft" = true ] && pr_flags="--draft"
        
        if gh pr create \
            --base "$base_branch" \
            --head "$branch" \
            --title "$pr_title" \
            --body "$(echo -e "$pr_body")" \
            $pr_flags \
            --repo "$(git -C "$worktree_path" remote get-url origin)" \
            2>&1; then
            log "âœ“ Created PR for $branch"
        else
            log "âœ— Failed to create PR for $branch"
            failed_pr="$branch"
            break
        fi
        log ""
    done
    
    if [ -n "$failed_pr" ]; then
        echo ""
        echo "Error: Failed to create PR for branch: $failed_pr" >&2
        return 1
    else
        log "All PRs created successfully!"
    fi
}

push_stack() {
    local push_all=false
    local dry_run=false
    
    # Parse push options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --all)
                push_all=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            *)
                echo "Error: Unknown option for push: $1" >&2
                return 1
                ;;
        esac
    done
    
    # Get all branches in the stack
    local branches=($(get_stack_branches))
    if [ ${#branches[@]} -eq 0 ]; then
        echo "Error: No branches found in stack" >&2
        return 1
    fi
    
    log "Checking branches in stack for push readiness..."
    log ""
    
    local branches_to_push=()
    local all_pass=true
    
    # Check each branch
    for branch in "${branches[@]}"; do
        local worktree_path=""
        if [ "$branch" = "main" ] || [ "$branch" = "master" ]; then
            worktree_path="$PROJECT_DIR"
        else
            worktree_path="$WORKTREES_DIR/$branch"
        fi
        
        if [ ! -d "$worktree_path" ]; then
            log "âœ— $branch - worktree not found"
            all_pass=false
            continue
        fi
        
        # Check if branch has commits not on remote
        local needs_push=false
        local remote_exists=false
        
        # Check if remote branch exists
        if git -C "$worktree_path" ls-remote --exit-code --heads origin "$branch" &>/dev/null; then
            remote_exists=true
            # Check if local is ahead of remote
            local ahead=$(git -C "$worktree_path" rev-list --count "origin/$branch..$branch" 2>/dev/null)
            if [ "$ahead" -gt 0 ]; then
                needs_push=true
            fi
        else
            # No remote branch, needs push if there are any commits
            if git -C "$worktree_path" rev-parse --verify "$branch" &>/dev/null; then
                needs_push=true
            fi
        fi
        
        if [ "$needs_push" = true ]; then
            # Check for uncommitted changes
            if ! git -C "$worktree_path" diff-index --quiet HEAD -- 2>/dev/null; then
                log "âœ— $branch - has uncommitted changes"
                all_pass=false
                continue
            fi
            
            if [ "$push_all" = true ] || [ "$remote_exists" = false ]; then
                branches_to_push+=("$branch")
                if [ "$remote_exists" = false ]; then
                    log "âœ“ $branch - ready to push (new branch)"
                else
                    log "âœ“ $branch - ready to push ($ahead commits ahead)"
                fi
            else
                log "âš  $branch - has unpushed changes ($ahead commits ahead, use --all to include)"
            fi
        else
            if [ "$remote_exists" = true ]; then
                log "âœ“ $branch - up to date"
            else
                log "âœ— $branch - no commits to push"
            fi
        fi
    done
    
    if [ ${#branches_to_push[@]} -eq 0 ]; then
        log ""
        log "No branches need pushing"
        return 0
    fi
    
    if [ "$all_pass" = false ] && [ "$push_all" = false ]; then
        log ""
        log "Some branches have issues. Fix them or use --all to push ready branches only."
        return 1
    fi
    
    log ""
    log "Branches to push: ${branches_to_push[*]}"
    
    if [ "$dry_run" = true ]; then
        log ""
        log "Dry run - no branches were pushed"
        return 0
    fi
    
    log ""
    log "Pushing branches..."
    log ""
    
    # Push each branch in order
    local failed_branch=""
    for branch in "${branches_to_push[@]}"; do
        local worktree_path=""
        if [ "$branch" = "main" ] || [ "$branch" = "master" ]; then
            worktree_path="$PROJECT_DIR"
        else
            worktree_path="$WORKTREES_DIR/$branch"
        fi
        
        log "Pushing $branch..."
        if git -C "$worktree_path" push -u origin "$branch" 2>&1; then
            log "âœ“ Pushed $branch"
        else
            log "âœ— Failed to push $branch"
            failed_branch="$branch"
            break
        fi
        log ""
    done
    
    if [ -n "$failed_branch" ]; then
        echo ""
        echo "Error: Failed to push branch: $failed_branch" >&2
        return 1
    else
        log "All branches pushed successfully!"
    fi
}

# Parse command line arguments
COMMAND=""
BRANCH=""
RUN_COMMAND=""
PUSH_STACK=false
PUSH_ALL=false
DRY_RUN=false
PR_STACK=false
PR_DRAFT=false
INSTALL_GIT_STACK=false
STACK_SUBCOMMAND=""
STACK_PARENT_BRANCH=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --quiet)
            QUIET=true
            shift
            ;;
        --stack)
            PUSH_STACK=true
            PR_STACK=true
            shift
            ;;
        --all)
            PUSH_ALL=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --draft)
            PR_DRAFT=true
            shift
            ;;
        --no-symlink)
            NO_SYMLINK=true
            shift
            ;;
        --switch)
            SWITCH_AFTER_CREATE=true
            shift
            ;;
        --pr-review)
            PR_REVIEW=true
            shift
            ;;
        --parent)
            shift
            if [[ $# -eq 0 ]]; then
                echo "Error: --parent requires a branch name" >&2
                exit 1
            fi
            PARENT_BRANCH="$1"
            PARENT_BRANCH_EXPLICIT=true
            shift
            ;;
        --dir)
            shift
            if [[ $# -eq 0 ]]; then
                echo "Error: --dir requires a directory path" >&2
                exit 1
            fi
            CHECK_DIR="$1"
            shift
            ;;
        --install)
            # Flag to trigger git-stack installation if not already present
            INSTALL_GIT_STACK=true
            shift
            ;;
        init|list|ls|create|rm|switch|merge|is-worktree|stack|sync|next|prev|run|push|pr)
            COMMAND="$1"
            shift
            # For 'run' command, capture everything else as the command to execute
            if [ "$COMMAND" = "run" ] && [ $# -gt 0 ]; then
                RUN_COMMAND="$*"
                break
            fi
            # For 'stack' command, check if there's a subcommand
            if [ "$COMMAND" = "stack" ] && [ $# -gt 0 ]; then
                case "$1" in
                    parent)
                        STACK_SUBCOMMAND="parent"
                        shift
                        if [ $# -gt 0 ]; then
                            STACK_PARENT_BRANCH="$1"
                            shift
                        fi
                        ;;
                    --install)
                        # Already handled by the --install flag
                        ;;
                    *)
                        # Not a recognized subcommand, might be a different argument
                        ;;
                esac
            fi
            ;;
        -h|--help|help)
            usage
            exit 0
            ;;
        *)
            # If we have a command that expects a branch and no branch is set yet,
            # treat this as the branch name
            if [[ -n "$COMMAND" ]] && [[ -z "$BRANCH" ]] && [[ "$COMMAND" =~ ^(create|rm|switch|merge|sync)$ ]]; then
                BRANCH="$1"
                shift
            else
                echo "Error: Unknown argument: $1" >&2
                usage
                exit 1
            fi
            ;;
    esac
done

# Execute the appropriate command
case "$COMMAND" in
    init)
        init_worktrees
        ;;
    list|ls)
        list_worktrees
        ;;
    create)
        create_worktree "$BRANCH"
        if [ "$SWITCH_AFTER_CREATE" = true ]; then
            switch_worktree "$BRANCH"
        fi
        ;;
    rm)
        remove_worktree "$BRANCH"
        ;;
    switch)
        switch_worktree "$BRANCH"
        ;;
    merge)
        merge_worktree "$BRANCH"
        ;;
    is-worktree)
        is_worktree
        ;;
    stack)
        # Check if there's a subcommand
        if [ "$STACK_SUBCOMMAND" = "parent" ]; then
            if [ -z "$STACK_PARENT_BRANCH" ]; then
                echo "Error: Parent branch name is required" >&2
                echo "Usage: wt stack parent <parent-branch>" >&2
                exit 1
            fi
            set_stack_parent "$STACK_PARENT_BRANCH"
        else
            show_worktree_stack
        fi
        ;;
    sync)
        sync_worktree_stack "$BRANCH"
        ;;
    next)
        navigate_stack "next"
        ;;
    prev)
        navigate_stack "prev"
        ;;
    run)
        run_across_stack "$RUN_COMMAND"
        ;;
    push)
        if [ "$PUSH_STACK" = true ]; then
            # Build options array
            push_opts=()
            [ "$PUSH_ALL" = true ] && push_opts+=("--all")
            [ "$DRY_RUN" = true ] && push_opts+=("--dry-run")
            push_stack "${push_opts[@]}"
        else
            echo "Error: push command requires --stack flag" >&2
            echo "Usage: wt push --stack [--all] [--dry-run]" >&2
            exit 1
        fi
        ;;
    pr)
        if [ "$PR_STACK" = true ]; then
            # Build options array
            pr_opts=()
            [ "$DRY_RUN" = true ] && pr_opts+=("--dry-run")
            [ "$PR_DRAFT" = true ] && pr_opts+=("--draft")
            create_stack_prs "${pr_opts[@]}"
        else
            echo "Error: pr command requires --stack flag" >&2
            echo "Usage: wt pr --stack [--draft] [--dry-run]" >&2
            exit 1
        fi
        ;;
    "")
        echo "Error: No command specified" >&2
        usage
        exit 1
        ;;
    *)
        echo "Error: Unknown command: $COMMAND" >&2
        usage
        exit 1
        ;;
esac

