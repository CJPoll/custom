#compdef wt

# Completion function for wt command

_wt() {
    local curcontext="$curcontext" state line
    
    _arguments -C \
        '1: :_wt_commands' \
        '--quiet[Suppress output from script and subcommands]' \
        '--stack[Execute command for entire stack (for pr commands)]' \
        '--dry-run[Show what would be done without actually doing it (for stack push/pr commands)]' \
        '--draft[Create draft pull requests (for pr --stack)]' \
        '*::arg:->args'
    
    case $state in
        args)
            case $words[1] in
                switch)
                    _arguments \
                        '1:branch:_wt_switchable_branches' \
                        '--pr-review[Open changed files in tabs for PR review]' \
                        '--parent[Parent branch for PR review]:branch:_wt_git_branches'
                    ;;
                rm|merge|worktree-dir)
                    _wt_worktrees
                    ;;
                close)
                    _alternative \
                        'worktrees:worktree:_wt_worktrees' \
                        'flags:flag:(--all)'
                    ;;
                init|list|reset|restack|next|prev)
                    # No additional arguments for these commands
                    _message 'no more arguments'
                    ;;
                sync)
                    _arguments \
                        '1:branch:_wt_worktrees' \
                        '--continue[Continue a sync operation after resolving conflicts]'
                    ;;
                create)
                    _arguments \
                        '1:branch:_wt_git_branches' \
                        '--no-symlink[Do not create symlink to .claude directory]' \
                        '--switch[Switch to the worktree after creating it]' \
                        '--parent[Parent branch for stack creation]:branch:_wt_git_branches' \
                        '--insert[Insert new branch between current and its children]' \
                        '(-m --message)'{-m,--message}'[Commit message]:message:' \
                        '(-a --all)'{-a,--all}'[Stage all changes before creating]' \
                        '--no-verify[Skip git hooks]'
                    ;;
                is-worktree)
                    _arguments \
                        '--dir[Check the specified directory]:directory:_directories'
                    ;;
                run)
                    _message 'command to run across stack'
                    ;;
                pr)
                    _arguments \
                        '--stack[Create pull requests for entire stack]' \
                        '--draft[Create draft pull requests]' \
                        '--publish[Publish draft PRs to ready state]' \
                        '--dry-run[Show what PRs would be created without creating them]'
                    ;;
                ls)
                    # ls is an alias for list, no additional arguments
                    _message 'no more arguments'
                    ;;
                stack)
                    # Handle stack subcommands
                    if [[ ${#words[@]} -eq 2 ]]; then
                        # First argument after 'stack'
                        local stack_subcommands=(
                            '--current:Show only the current branch stack'
                            '--install:Install Graphite (gt) if not already installed'
                            'parent:Set or update the parent branch for the current branch'
                            'track:Track a branch with Graphite (delegates to gt track)'
                            'open:Create worktrees for all branches in the stack up to the given branch'
                            'move:Change parent or reorder branches in the stack'
                            'reorder:Rearrange multiple branches in the stack interactively'
                            'rename:Rename the current branch'
                            'push:Push all branches in the stack using Graphite'
                        )
                        _describe -t stack-subcommands 'stack subcommand' stack_subcommands
                    elif [[ ${#words[@]} -ge 3 ]]; then
                        case ${words[2]} in
                            parent)
                                _arguments \
                                    '1:parent branch:_wt_git_branches'
                                ;;
                            track)
                                _arguments \
                                    '--parent[Set parent branch when tracking]:branch:_wt_git_branches'
                                ;;
                            open)
                                # Complete branch names and flags for open subcommand
                                _alternative \
                                    'branches:branch:_wt_git_branches' \
                                    'flags:flag:(--create-sessions)'
                                ;;
                            move)
                                _arguments \
                                    '--onto[Move branch onto new parent]:parent:_wt_git_branches' \
                                    '--up[Move branch up among siblings]' \
                                    '--down[Move branch down among siblings]' \
                                    '--dry-run[Preview changes without applying]'
                                ;;
                            reorder)
                                # No additional arguments for reorder (interactive mode)
                                ;;
                            rename)
                                _arguments \
                                    '1:new name:' \
                                    '(-f --force)'{-f,--force}'[Allow renaming branch with open PR]'
                                ;;
                            push)
                                _arguments \
                                    '(-f --force)'{-f,--force}'[Force push branches]' \
                                    '--dry-run[Show what would be pushed without pushing]'
                                ;;
                            --current|--install)
                                # No additional arguments for these flags
                                ;;
                        esac
                    fi
                    ;;
                migrate-to-gt)
                    # No additional arguments needed for migration
                    _message 'no more arguments'
                    ;;
                change)
                    # Handle change subcommands
                    if [[ ${#words[@]} -eq 2 ]]; then
                        # First argument after 'change'
                        local change_subcommands=(
                            'amend:Amend current commit with auto-restacking'
                            'absorb:Auto-apply changes to relevant commits in stack'
                            'split:Split current branch into multiple branches'
                            'squash:Squash all commits in branch into one'
                        )
                        _describe -t change-subcommands 'change subcommand' change_subcommands
                    elif [[ ${#words[@]} -ge 3 ]]; then
                        case ${words[2]} in
                            amend)
                                _arguments \
                                    '(-c --commit)'{-c,--commit}'[Create new commit instead of amending]' \
                                    '(-a --all)'{-a,--all}'[Stage all changes before committing]' \
                                    '(-m --message)'{-m,--message}'[Commit message]:message:' \
                                    '(-e --edit)'{-e,--edit}'[Edit commit message]' \
                                    '(-u --update)'{-u,--update}'[Stage updates to tracked files]' \
                                    '(-p --patch)'{-p,--patch}'[Pick hunks to stage]'
                                ;;
                            absorb)
                                _arguments \
                                    '(-a --all)'{-a,--all}'[Stage all changes before absorbing]' \
                                    '(-d --dry-run)'{-d,--dry-run}'[Preview where changes would be absorbed]' \
                                    '(-p --patch)'{-p,--patch}'[Pick hunks to stage before absorbing]' \
                                    '(-f --force)'{-f,--force}'[Do not prompt for confirmation]'
                                ;;
                            split)
                                _arguments \
                                    '(-c --by-commit --commit)'{-c,--by-commit,--commit}'[Split by commit - slice up the history]' \
                                    '(-h --by-hunk --hunk)'{-h,--by-hunk,--hunk}'[Split by hunk - interactively split into new branches]'
                                ;;
                            squash)
                                _arguments \
                                    '(-m --message)'{-m,--message}'[Updated message for the squashed commit]:message:' \
                                    '--edit[Modify the existing commit message]' \
                                    '(-n --no-edit)'{-n,--no-edit}'[Do not modify the commit message]'
                                ;;
                        esac
                    fi
                    ;;
                continue)
                    _arguments \
                        '--abort[Abort the current operation]'
                    ;;
            esac
            ;;
    esac
}

_wt_commands() {
    local commands=(
        'init:Set up the worktrees directory'
        'list:List all worktrees for the current project'
        'ls:List all worktrees for the current project (alias for list)'
        'create:Create a worktree for the specified branch'
        'rm:Remove the worktree for the specified branch'
        'close:Remove worktree and delete the local branch (use --all for all branches)'
        'reset:Remove all worktrees and delete their branches (skips main/master)'
        'switch:Change to the worktree for the specified branch'
        'merge:Merge a worktree branch (must be run from parent repo)'
        'worktree-dir:Get the directory path for a branch worktree'
        'is-worktree:Check if a directory is a git worktree'
        'stack:Show branch hierarchy using Graphite (use --current for current stack only, open to create worktrees)'
        'sync:Sync the stack by rebasing child branches onto updated parents'
        'restack:Fix stack relationships and rebase onto correct parents'
        'next:Navigate to a child branch in the stack (switch tmux session)'
        'prev:Navigate to the parent branch in the stack (switch tmux session)'
        'run:Execute a command across all branches in the stack'
        'pr:Create pull requests (use --stack for entire stack)'
        'migrate-to-gt:Migrate existing git-stack metadata to Graphite format'
        'change:Modify commits in the stack (amend, absorb, split)'
        'continue:Resume paused operation after resolving conflicts (delegates to gt)'
    )
    _describe -t commands 'wt command' commands
}

# Helper function to get the project name (handles being inside a worktree)
_wt_get_project_name() {
    local current_dir="$(pwd)"
    local project_dir="$current_dir"

    # Check if we're in a worktree by looking for .git file (not directory)
    if [[ -f "$current_dir/.git" ]]; then
        # We're in a worktree, extract the actual project path
        local git_dir=$(grep "gitdir:" "$current_dir/.git" | cut -d' ' -f2)
        # Git dir for worktree looks like: /path/to/project/.git/worktrees/branch-name
        # We need to go up 3 levels to get the project root
        project_dir=$(dirname $(dirname $(dirname "$git_dir")))
    fi

    basename "$project_dir"
}

# Function to complete worktree names
_wt_worktrees() {
    local project_name="$(_wt_get_project_name)"
    local worktrees_dir="$HOME/.local/worktrees/$project_name"
    local -a worktrees

    if [[ -d "$worktrees_dir" ]]; then
        # Get worktrees by listing directories in the worktrees folder
        # This is more reliable than parsing git worktree list
        local dir
        for dir in "$worktrees_dir"/*(/N); do
            if [[ -n "$dir" ]]; then
                local branch="${dir#$worktrees_dir/}"
                if [[ -n "$branch" ]]; then
                    worktrees+=("$branch")
                fi
            fi
        done

        # Also check git worktree list for any we might have missed
        local git_output
        git_output=$(git worktree list 2>/dev/null)

        if [[ -n "$git_output" ]]; then
            while IFS= read -r line; do
                local worktree_path="${line%% *}"
                if [[ "$worktree_path" == "$worktrees_dir/"* ]]; then
                    local branch="${worktree_path#$worktrees_dir/}"
                    if [[ -n "$branch" ]] && (( ! ${worktrees[(Ie)$branch]} )); then
                        worktrees+=("$branch")
                    fi
                fi
            done <<< "$git_output"
        fi

        # Remove duplicates and use _multi_parts for slash-separated completion
        worktrees=(${(u)worktrees})

        if (( ${#worktrees} > 0 )); then
            _multi_parts / worktrees
        fi
    fi
}

# Function to complete git branch names
_wt_git_branches() {
    # Get all branches (local and remote)
    local -a branches
    branches=(${(f)"$(git for-each-ref --format='%(refname:short)' refs/heads refs/remotes 2>/dev/null | grep -v HEAD | sed 's|^origin/||' | sort -u)"})
    
    _multi_parts / branches
}

# Function to complete branches for switch command
_wt_switchable_branches() {
    # Get all local branches
    local -a branches
    branches=(${(f)"$(git for-each-ref --format='%(refname:short)' refs/heads 2>/dev/null)"})

    # Also get branches that have worktrees by checking the worktrees directory directly
    local project_name="$(_wt_get_project_name)"
    local worktrees_dir="$HOME/.local/worktrees/$project_name"
    if [[ -d "$worktrees_dir" ]]; then
        # Get directories directly from the worktrees folder
        local -a worktree_dirs
        worktree_dirs=(${(f)"$(ls -1 "$worktrees_dir" 2>/dev/null)"})

        # Add each worktree directory as a potential branch
        for dir in "${worktree_dirs[@]}"; do
            if [[ -n "$dir" ]] && (( ! ${branches[(Ie)$dir]} )); then
                branches+=("$dir")
            fi
        done

        # Also check git worktree list in case some are registered
        local git_output
        git_output=$(git worktree list 2>/dev/null)

        if [[ -n "$git_output" ]]; then
            while IFS= read -r line; do
                # Extract the path and branch from each line
                local worktree_path="${line%% *}"
                local branch_info="${line#* }"
                # Extract branch name from format like "abc123 [branch-name]"
                if [[ "$branch_info" =~ \[([^\]]+)\] ]]; then
                    local branch="${match[1]}"
                    # Add to branches if not already present (using zsh array search)
                    if (( ! ${branches[(Ie)$branch]} )); then
                        branches+=("$branch")
                    fi
                fi
            done <<< "$git_output"
        fi
    fi

    # Sort and remove duplicates
    branches=(${(u)branches})

    if (( ${#branches} > 0 )); then
        _multi_parts / branches
    fi
}

_wt "$@"
