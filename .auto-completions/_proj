#compdef proj

# Get all immediate subdirectories from DEVPATH directories
_proj_get_projects() {
  local IFS=':'
  local projects=()
  
  # Split DEVPATH and iterate through each directory
  for dir in ${=DEVPATH}; do
    if [[ -d "$dir" ]]; then
      # Find immediate subdirectories (maxdepth 1)
      for project in "$dir"/*(N/); do
        projects+=(${project:t})  # :t gets the tail (basename)
      done
    fi
  done
  
  # Remove duplicates and sort
  echo ${(ou)projects}
}

# Function to complete git branch names
_git_branch_names() {
  # Get all branches (local and remote)
  local -a branches
  branches=(${(f)"$(git for-each-ref --format='%(refname:short)' refs/heads refs/remotes 2>/dev/null | grep -v HEAD | sed 's|^origin/||' | sort -u)"})
  
  _multi_parts / branches
}

_arguments -C \
  '1: :->command_or_project' \
  '--path[Explicit path to project directory]:directory:_directories' \
  '--pr-review[Open changed files in tabs for PR review]' \
  '--base-branch[Base branch for PR review]:branch:_git_branch_names' \
  '--no-switch[Create/configure session but do not switch to it]' \
  '(-h --help)'{-h,--help}'[Show help message]' \
  '*::arg:->args'

case $state in
  command_or_project)
    # Check if first word is 'print' command
    if [[ ${words[CURRENT]} == "print" ]] || [[ $CURRENT -eq 1 ]]; then
      local -a commands
      commands=(
        'print:Print the full path to the project directory'
      )
      _describe -t commands 'proj command' commands
    fi

    # Always offer projects as completion
    local -a projects
    projects=($(_proj_get_projects))
    _describe -t projects 'project' projects
    ;;
  args)
    # If first word was 'print', complete with project names
    if [[ ${words[2]} == "print" ]]; then
      local -a projects
      projects=($(_proj_get_projects))
      _describe -t projects 'project' projects
    fi
    ;;
esac
